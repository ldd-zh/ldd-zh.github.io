<!DOCTYPE html> <html><head>
		<title>4.6  调试器及相关工具</title>
		<base href="../">
		<meta id="root-path" root-path="../">
		<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes, minimum-scale=1.0, maximum-scale=5.0">
		<meta charset="UTF-8">
		<meta name="description" content="ldd_zh - 4.6  调试器及相关工具">
		<meta property="og:title" content="4.6  调试器及相关工具">
		<meta property="og:description" content="ldd_zh - 4.6  调试器及相关工具">
		<meta property="og:type" content="website">
		<meta property="og:url" content="第4章-调试技术/4.6-调试器及相关工具.html">
		<meta property="og:image" content="undefined">
		<meta property="og:site_name" content="ldd_zh">
		<link rel="alternate" type="application/rss+xml" title="RSS Feed" href="lib/rss.xml"><script async="" id="webpage-script" src="lib/scripts/webpage.js" onload="this.onload=null;this.setAttribute(&quot;loaded&quot;, &quot;true&quot;)"></script><script type="module" async="" id="graph-view-script" src="lib/scripts/graph-view.js"></script><script async="" id="graph-wasm-script" src="lib/scripts/graph-wasm.js" onload="this.onload=null;this.setAttribute(&quot;loaded&quot;, &quot;true&quot;)"></script><script async="" id="graph-render-worker-script" src="lib/scripts/graph-render-worker.js" onload="this.onload=null;this.setAttribute(&quot;loaded&quot;, &quot;true&quot;)"></script><script async="" id="tinycolor-script" src="lib/scripts/tinycolor.js" onload="this.onload=null;this.setAttribute(&quot;loaded&quot;, &quot;true&quot;)"></script><script async="" id="pixi-script" src="https://cdnjs.cloudflare.com/ajax/libs/pixi.js/7.4.0/pixi.min.js" onload="this.onload=null;this.setAttribute(&quot;loaded&quot;, &quot;true&quot;)"></script><script async="" id="minisearch-script" src="https://cdn.jsdelivr.net/npm/minisearch@6.3.0/dist/umd/index.min.js" onload="this.onload=null;this.setAttribute(&quot;loaded&quot;, &quot;true&quot;)"></script><link rel="icon" href="lib/media/favicon.png"><script async="" id="graph-data-script" src="lib/scripts/graph-data.js" onload="this.onload=null;this.setAttribute(&quot;loaded&quot;, &quot;true&quot;)"></script><style>body{--line-width:40em;--line-width-adaptive:40em;--file-line-width:40em;--sidebar-width:min(20em, 80vw);--collapse-arrow-size:11px;--tree-horizontal-spacing:0.6em;--tree-vertical-spacing:0.6em;--sidebar-margin:12px}.sidebar{height:100%;min-width:calc(var(--sidebar-width) + var(--divider-width-hover));max-width:calc(var(--sidebar-width) + var(--divider-width-hover));font-size:14px;z-index:10;position:relative;overflow:hidden;transition:min-width ease-in-out,max-width ease-in-out;transition-duration:.2s;contain:size}.sidebar-left{left:0}.sidebar-right{right:0}.sidebar.is-collapsed{min-width:0;max-width:0}body.floating-sidebars .sidebar{position:absolute}.sidebar-content{height:100%;min-width:calc(var(--sidebar-width) - var(--divider-width-hover));top:0;padding:var(--sidebar-margin);padding-top:4em;line-height:var(--line-height-tight);background-color:var(--background-secondary);transition:background-color,border-right,border-left,box-shadow;transition-duration:var(--color-fade-speed);transition-timing-function:ease-in-out;position:absolute;display:flex;flex-direction:column}.sidebar:not(.is-collapsed) .sidebar-content{min-width:calc(max(100%,var(--sidebar-width)) - 3px);max-width:calc(max(100%,var(--sidebar-width)) - 3px)}.sidebar-left .sidebar-content{left:0;border-top-right-radius:var(--radius-l);border-bottom-right-radius:var(--radius-l)}.sidebar-right .sidebar-content{right:0;border-top-left-radius:var(--radius-l);border-bottom-left-radius:var(--radius-l)}.sidebar:has(.sidebar-content:empty):has(.topbar-content:empty){display:none}.sidebar-topbar{height:2em;width:var(--sidebar-width);top:var(--sidebar-margin);padding-inline:var(--sidebar-margin);z-index:1;position:fixed;display:flex;align-items:center;transition:width ease-in-out;transition-duration:inherit}.sidebar.is-collapsed .sidebar-topbar{width:calc(2.3em + var(--sidebar-margin) * 2)}.sidebar .sidebar-topbar.is-collapsed{width:0}.sidebar-left .sidebar-topbar{left:0}.sidebar-right .sidebar-topbar{right:0}.topbar-content{overflow:hidden;overflow:clip;width:100%;height:100%;display:flex;align-items:center;transition:inherit}.sidebar.is-collapsed .topbar-content{width:0;transition:inherit}.clickable-icon.sidebar-collapse-icon{background-color:transparent;color:var(--icon-color-focused);padding:0!important;margin:0!important;height:100%!important;width:2.3em!important;margin-inline:0.14em!important;position:absolute}.sidebar-left .clickable-icon.sidebar-collapse-icon{transform:rotateY(180deg);right:var(--sidebar-margin)}.sidebar-right .clickable-icon.sidebar-collapse-icon{transform:rotateY(180deg);left:var(--sidebar-margin)}.clickable-icon.sidebar-collapse-icon svg.svg-icon{width:100%;height:100%}.sidebar-section-header{margin:0 0 1em 0;text-transform:uppercase;letter-spacing:.06em;font-weight:600}body{transition:background-color var(--color-fade-speed) ease-in-out}.webpage-container{display:flex;flex-direction:row;height:100%;width:100%;align-items:stretch;justify-content:center}.document-container{opacity:1;flex-basis:100%;max-width:100%;width:100%;height:100%;display:flex;flex-direction:column;align-items:center;transition:opacity .2s ease-in-out;contain:inline-size}.hide{opacity:0;transition:opacity .2s ease-in-out}.document-container>.markdown-preview-view{margin:var(--sidebar-margin);margin-bottom:0;width:100%;width:-webkit-fill-available;width:-moz-available;width:fill-available;background-color:var(--background-primary);transition:background-color var(--color-fade-speed) ease-in-out;border-top-right-radius:var(--window-radius,var(--radius-m));border-top-left-radius:var(--window-radius,var(--radius-m));overflow-x:hidden!important;overflow-y:auto!important;display:flex!important;flex-direction:column!important;align-items:center!important;contain:inline-size}.document-container>.markdown-preview-view>.markdown-preview-sizer{padding-bottom:80vh!important;width:100%!important;max-width:var(--line-width)!important;flex-basis:var(--line-width)!important;transition:background-color var(--color-fade-speed) ease-in-out;contain:inline-size}.markdown-rendered img:not([width]),.view-content img:not([width]){max-width:100%;outline:0}.document-container>.view-content.embed{display:flex;padding:1em;height:100%;width:100%;align-items:center;justify-content:center}.document-container>.view-content.embed>*{max-width:100%;max-height:100%;object-fit:contain}:has(> :is(.math,table)){overflow-x:auto!important}.document-container>.view-content{overflow-x:auto;contain:content;padding:0;margin:0;height:100%}.scroll-highlight{position:absolute;width:100%;height:100%;pointer-events:none;z-index:1000;background-color:hsla(var(--color-accent-hsl),.25);opacity:0;padding:1em;inset:50%;translate:-50% -50%;border-radius:var(--radius-s)}</style><script defer="">async function loadIncludes(){if("file:"!=location.protocol){let e=document.querySelectorAll("include");for(let t=0;t<e.length;t++){let o=e[t],l=o.getAttribute("src");try{const e=await fetch(l);if(!e.ok){console.log("Could not include file: "+l),o?.remove();continue}let t=await e.text(),n=document.createRange().createContextualFragment(t),i=Array.from(n.children);for(let e of i)e.classList.add("hide"),e.style.transition="opacity 0.5s ease-in-out",setTimeout((()=>{e.classList.remove("hide")}),10);o.before(n),o.remove(),console.log("Included file: "+l)}catch(e){o?.remove(),console.log("Could not include file: "+l,e);continue}}}else{if(document.querySelectorAll("include").length>0){var e=document.createElement("div");e.id="error",e.textContent="Web server exports must be hosted on an http / web server to be viewed correctly.",e.style.position="fixed",e.style.top="50%",e.style.left="50%",e.style.transform="translate(-50%, -50%)",e.style.fontSize="1.5em",e.style.fontWeight="bold",e.style.textAlign="center",document.body.appendChild(e),document.querySelector(".document-container")?.classList.remove("hide")}}}document.addEventListener("DOMContentLoaded",(()=>{loadIncludes()}));let isFileProtocol="file:"==location.protocol;function waitLoadScripts(e,t){let o=e.map((e=>document.getElementById(e+"-script"))),l=0;!function e(){let n=o[l];l++,n&&"true"!=n.getAttribute("loaded")||l<o.length&&e(),l<o.length?n.addEventListener("load",e):t()}()}</script><link rel="stylesheet" href="lib/styles/obsidian.css"><link rel="stylesheet" href="lib/styles/theme.css"><link rel="preload" href="lib/styles/global-variable-styles.css" as="style" onload="this.onload=null;this.rel='stylesheet'"><noscript><link rel="stylesheet" href="lib/styles/global-variable-styles.css"></noscript><link rel="preload" href="lib/styles/main-styles.css" as="style" onload="this.onload=null;this.rel='stylesheet'"><noscript><link rel="stylesheet" href="lib/styles/main-styles.css"></noscript></head><body class="publish css-settings-manager native-scrollbars theme-light show-inline-title show-ribbon"><script defer="">let theme=localStorage.getItem("theme")||(window.matchMedia("(prefers-color-scheme: dark)").matches?"dark":"light");"dark"==theme?(document.body.classList.add("theme-dark"),document.body.classList.remove("theme-light")):(document.body.classList.add("theme-light"),document.body.classList.remove("theme-dark")),window.innerWidth<480?document.body.classList.add("is-phone"):window.innerWidth<768?document.body.classList.add("is-tablet"):window.innerWidth<1024?document.body.classList.add("is-small-screen"):document.body.classList.add("is-large-screen")</script><div class="webpage-container workspace"><div class="sidebar-left sidebar"><div class="sidebar-handle"></div><div class="sidebar-topbar"><div class="topbar-content"><label class="theme-toggle-container" for="theme_toggle"><input class="theme-toggle-input" type="checkbox" id="theme_toggle"><div class="toggle-background"></div></label></div><div class="clickable-icon sidebar-collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="100%" height="100%" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="3" stroke-linecap="round" stroke-linejoin="round" class="svg-icon"><path d="M21 3H3C1.89543 3 1 3.89543 1 5V19C1 20.1046 1.89543 21 3 21H21C22.1046 21 23 20.1046 23 19V5C23 3.89543 22.1046 3 21 3Z"></path><path d="M10 4V20"></path><path d="M4 7H7"></path><path d="M4 10H7"></path><path d="M4 13H7"></path></svg></div></div><div class="sidebar-content"><div class="search-input-container"><input enterkeyhint="search" type="search" spellcheck="false" placeholder="Search..."><div class="search-input-clear-button" aria-label="Clear search"></div></div><include src="lib/html/file-tree.html"></include></div><script defer="">let ls = document.querySelector(".sidebar-left"); ls.classList.add("is-collapsed"); if (window.innerWidth > 768) ls.classList.remove("is-collapsed"); ls.style.setProperty("--sidebar-width", localStorage.getItem("sidebar-left-width"));</script></div><div class="document-container markdown-reading-view hide"><div class="markdown-preview-view markdown-rendered allow-fold-headings allow-fold-lists is-readable-line-width"><style id="MJX-CHTML-styles"></style><div class="markdown-preview-sizer markdown-preview-section"><h1 class="page-title heading inline-title" id="4.6  调试器及相关工具">4.6  调试器及相关工具</h1><div class="el-p"><p dir="auto">调试模块的最后手段是使用调试器逐步执行代码，观察变量和机器寄存器的值。这种方法耗时，应尽可能避免。然而，通过调试器实现的代码细粒度视角有时是无价的。</p></div><div class="el-p"><p dir="auto">在内核上使用交互式调试器是一个挑战。内核在自己的地址空间中运行，代表系统中的所有进程。因此，用户空间调试器提供的许多常见功能（如断点和单步执行）在内核中更难实现。在本节中，我们将介绍几种调试内核的方法；每种方法都有其优缺点。</p></div><div class="el-h2 heading-wrapper"><h2 data-heading="使用 `gdb`" dir="auto" class="heading" id="使用_`gdb`"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>使用 <code>gdb</code></h2><div class="heading-children"><div class="el-p"><p dir="auto"><code>gdb</code> 对于查看系统内部非常有用。在这个级别熟练使用调试器需要对 <code>gdb</code> 命令有一定的信心，对目标平台的汇编代码有一定的理解，以及能够匹配源代码和优化的汇编代码。</p></div><div class="el-p"><p dir="auto">调试器必须像内核是一个应用程序一样调用。除了指定 ELF 内核映像的文件名外，你还需要在命令行上提供一个核心文件的名称。对于正在运行的内核，该核心文件是内核核心映像 <code>/proc/kcore</code>。典型的 <code>gdb</code> 调用如下所示：</p></div><div class="el-pre"><pre class="language-bash" tabindex="0"><code data-line="0" class="language-bash is-loaded">gdb /usr/src/linux/vmlinux /proc/kcore
</code><button class="copy-code-button"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon lucide-copy"><rect x="8" y="8" width="14" height="14" rx="2" ry="2"></rect><path d="M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2"></path></svg></button></pre></div><div class="el-p"><p dir="auto">第一个参数是未压缩的 ELF 内核可执行文件的名称，而不是 <code>zImage</code> 或 <code>bzImage</code> 或任何专门为引导环境构建的内容。</p></div><div class="el-p"><p dir="auto"><code>gdb</code> 命令行上的第二个参数是核心文件的名称。像 <code>/proc/</code> 中的任何文件一样，<code>/proc/kcore</code> 是在读取时生成的。当 <code>read</code> 系统调用在 <code>/proc</code> 文件系统中执行时，它映射到数据生成函数而不是数据检索函数；我们已经在本章前面的“使用 <code>/proc</code> 文件系统”部分中利用了此功能。<code>kcore</code> 用于表示内核“可执行文件”的核心文件格式；它是一个巨大的文件，因为它表示整个内核地址空间，对应于所有物理内存。在 <code>gdb</code> 中，你可以通过发出标准的 <code>gdb</code> 命令来查看内核变量。例如，<code>p jiffies</code> 打印从系统启动到当前时间的时钟滴答数。</p></div><div class="el-p"><p dir="auto">当你在 <code>gdb</code> 中打印数据时，内核仍在运行，各种数据项在不同时间具有不同的值；然而，<code>gdb</code> 通过缓存已读取的数据来优化对核心文件的访问。如果你再次查看 <code>jiffies</code> 变量，你将得到与之前相同的答案。缓存值以避免额外的磁盘访问是传统核心文件的正确行为，但在使用“动态”核心映像时很不方便。解决方案是在每次想要刷新 <code>gdb</code> 缓存时发出命令 <code>core-file /proc/kcore</code>；调试器准备好使用新的核心文件并丢弃任何旧信息。然而，你并不总是需要在读取新数据时发出 <code>core-file</code>；<code>gdb</code> 以几千字节的块读取核心文件，并且只缓存它已经引用的块。</p></div><div class="el-p"><p dir="auto">通常由 <code>gdb</code> 提供的许多功能在内核上不可用。例如，<code>gdb</code> 无法修改内核数据；它期望在控制下运行要调试的程序，然后再处理其内存映像。也无法设置断点或观察点，或单步执行内核函数。</p></div><div class="el-p"><p dir="auto">请注意，为了在 <code>gdb</code> 中提供符号信息，你必须在编译内核时启用 <code>CONFIG_DEBUG_INFO</code> 选项。结果是在磁盘上生成一个更大的内核映像，但没有这些信息，挖掘内核变量几乎是不可能的。</p></div><div class="el-p"><p dir="auto">有了调试信息，你可以了解内核内部发生的许多事情。<code>gdb</code> 可以愉快地打印结构、跟踪指针等。然而，更难的是检查模块。由于模块不是传递给 <code>gdb</code> 的 <code>vmlinux</code> 映像的一部分，调试器对它们一无所知。幸运的是，从内核 2.6.7 开始，可以教 <code>gdb</code> 它需要了解的内容以检查可加载模块。</p></div><div class="el-p"><p dir="auto">Linux 可加载模块是 ELF 格式的可执行映像；因此，它们被划分为许多部分。一个典型的模块可能包含十几个或更多部分，但在调试会话中通常只有三个相关部分：</p></div><div class="el-ul"><ul>
<li data-line="0" dir="auto">
<p><strong>.text</strong><br>
此部分包含模块的可执行代码。调试器必须知道此部分的位置才能提供回溯或设置断点。（当在 <code>/proc/kcore</code> 上运行调试器时，这些操作都不相关，但在使用 <code>kgdb</code> 时可能有用，稍后描述）。</p>
</li>
<li data-line="3" dir="auto">
<p><strong>.bss</strong>  </p>
</li>
<li data-line="4" dir="auto">
<p><strong>.data</strong><br>
这两个部分保存模块的变量。任何在编译时未初始化的变量最终都会进入 <code>.bss</code>，而初始化的变量则进入 <code>.data</code>。</p>
</li>
</ul></div><div class="el-p"><p dir="auto">让 <code>gdb</code> 与可加载模块一起工作需要告知调试器给定模块的各个部分加载到哪里。该信息在 <code>sysfs</code> 中可用，位于 <code>/sys/module</code> 下。例如，加载 <code>scull</code> 模块后，目录 <code>/sys/module/scull/sections</code> 包含名为 <code>.text</code> 的文件；每个文件的内容是该部分的基地址。</p></div><div class="el-p"><p dir="auto">我们现在可以发出一个 <code>gdb</code> 命令，告诉它我们的模块。我们需要的命令是 <code>add-symbol-file</code>；该命令将模块对象文件的名称、<code>.text</code> 基地址和一系列可选参数作为参数，描述其他感兴趣的部分的位置。在挖掘 <code>sysfs</code> 中的模块部分数据后，我们可以构建如下命令：</p></div><div class="el-pre"><pre class="language-bash" tabindex="0"><code data-line="0" class="language-bash is-loaded"><span class="token punctuation">(</span>gdb<span class="token punctuation">)</span> add-symbol-file <span class="token punctuation">..</span>./scull.ko 0xd0832000 <span class="token punctuation">\</span>
    <span class="token parameter variable">-s</span> .bss 0xd0837100 <span class="token punctuation">\</span>
    <span class="token parameter variable">-s</span> .data 0xd0836be0
</code><button class="copy-code-button"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon lucide-copy"><rect x="8" y="8" width="14" height="14" rx="2" ry="2"></rect><path d="M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2"></path></svg></button></pre></div><div class="el-p"><p dir="auto">我们在示例源代码中包含了一个小脚本（<code>gdbline</code>），它可以为给定模块创建此命令。</p></div><div class="el-p"><p dir="auto">我们现在可以使用 <code>gdb</code> 检查可加载模块中的变量。以下是来自 <code>scull</code> 调试会话的快速示例：</p></div><div class="el-pre"><pre class="language-bash" tabindex="0"><code data-line="0" class="language-bash is-loaded"><span class="token punctuation">(</span>gdb<span class="token punctuation">)</span> add-symbol-file scull.ko 0xd0832000 <span class="token punctuation">\</span>
    <span class="token parameter variable">-s</span> .bss 0xd0837100 <span class="token punctuation">\</span>
    <span class="token parameter variable">-s</span> .data 0xd0836be0
<span class="token function">add</span> symbol table from <span class="token function">file</span> <span class="token string">"scull.ko"</span> at
    .text_addr <span class="token operator">=</span> 0xd0832000
    .bss_addr <span class="token operator">=</span> 0xd0837100
    .data_addr <span class="token operator">=</span> 0xd0836be0
<span class="token punctuation">(</span>y or n<span class="token punctuation">)</span> y
Reading symbols from scull.ko<span class="token punctuation">..</span>.done.
<span class="token punctuation">(</span>gdb<span class="token punctuation">)</span> p scull_devices<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>
<span class="token variable">$1</span> <span class="token operator">=</span> <span class="token punctuation">{</span>data <span class="token operator">=</span> 0xc7666c50,
    quantum <span class="token operator">=</span> <span class="token number">4000</span>,
    qset <span class="token operator">=</span> <span class="token number">1000</span>,
    size <span class="token operator">=</span> <span class="token number">20881</span>,
    access_key <span class="token operator">=</span> <span class="token number">0</span>,
    <span class="token punctuation">..</span>.<span class="token punctuation">}</span>
</code><button class="copy-code-button"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon lucide-copy"><rect x="8" y="8" width="14" height="14" rx="2" ry="2"></rect><path d="M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2"></path></svg></button></pre></div><div class="el-p"><p dir="auto">在这里，我们看到第一个 <code>scull</code> 设备当前持有 20,881 字节。如果我们愿意，我们可以跟随数据链，或查看模块中任何其他感兴趣的内容。</p></div><div class="el-p"><p dir="auto">另一个值得了解的技巧是：</p></div><div class="el-pre"><pre class="language-bash" tabindex="0"><code data-line="0" class="language-bash is-loaded"><span class="token punctuation">(</span>gdb<span class="token punctuation">)</span> print *<span class="token punctuation">(</span>address<span class="token punctuation">)</span>
</code><button class="copy-code-button"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon lucide-copy"><rect x="8" y="8" width="14" height="14" rx="2" ry="2"></rect><path d="M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2"></path></svg></button></pre></div><div class="el-p"><p dir="auto">在这里，为 <code>address</code> 填入一个十六进制地址；输出是对应于该地址的代码的文件和行号。此技术可能有用，例如，找出函数指针真正指向的位置。</p></div><div class="el-p"><p dir="auto">我们仍然无法执行典型的调试任务，如设置断点或修改数据；要执行这些操作，我们需要使用像 <code>kdb</code>（接下来描述）或 <code>kgdb</code>（我们稍后会讨论）这样的工具。</p></div></div></div><div class="el-h2 heading-wrapper"><h2 data-heading="`kdb` 内核调试器" dir="auto" class="heading" id="`kdb`_内核调试器"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><code>kdb</code> 内核调试器</h2><div class="heading-children"><div class="el-p"><p dir="auto">许多读者可能想知道为什么内核没有内置更高级的调试功能。答案很简单，Linus 不相信交互式调试器。他担心它们会导致糟糕的修复，那些修补症状而不是解决问题的根本原因。因此，没有内置调试器。</p></div><div class="el-p"><p dir="auto">然而，其他内核开发者认为交互式调试工具有时有用。其中一个工具是 <code>kdb</code> 内置内核调试器，可从 <code>oss.sgi.com</code> 作为非官方补丁获得。要使用 <code>kdb</code>，你必须获取补丁（确保获取与内核版本匹配的版本），应用它，然后重新构建和重新安装内核。请注意，截至本文撰写时，<code>kdb</code> 仅在 IA-32（x86）系统上工作（尽管 IA-64 的版本曾一度存在于主线内核源代码中，后来被移除）。</p></div><div class="el-p"><p dir="auto">一旦你运行了启用 <code>kdb</code> 的内核，有几种方法可以进入调试器。按下控制台上的 <code>Pause</code>（或 <code>Break</code>）键会启动调试器。当内核发生 <code>oops</code> 或命中断点时，<code>kdb</code> 也会启动。无论如何，你会看到如下消息：</p></div><div class="el-pre"><pre class="language-bash" tabindex="0"><code data-line="0" class="language-bash is-loaded">Entering kdb <span class="token punctuation">(</span>0xc0347b80<span class="token punctuation">)</span> on processor <span class="token number">0</span> due to keyboard Entry
<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>kdb<span class="token operator">&gt;</span>
</code><button class="copy-code-button"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon lucide-copy"><rect x="8" y="8" width="14" height="14" rx="2" ry="2"></rect><path d="M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2"></path></svg></button></pre></div><div class="el-p"><p dir="auto">请注意，当 <code>kdb</code> 运行时，内核几乎停止了一切。在调用 <code>kdb</code> 的系统上，不应运行其他任何东西；特别是，你不应启用网络——当然，除非你正在调试网络驱动程序。通常，如果你要使用 <code>kdb</code>，最好以单用户模式启动系统。</p></div><div class="el-p"><p dir="auto">作为一个示例，考虑一个快速的 <code>scull</code> 调试会话。假设驱动程序已经加载，我们可以告诉 <code>kdb</code> 在 <code>scull_read</code> 中设置一个断点，如下所示：</p></div><div class="el-pre"><pre class="language-bash" tabindex="0"><code data-line="0" class="language-bash is-loaded"><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>kdb<span class="token operator">&gt;</span> bp scull_read
Instruction<span class="token punctuation">(</span>i<span class="token punctuation">)</span> BP <span class="token comment">#0 at 0xc0087c5dc (scull_read)</span>
is enabled globally adjust <span class="token number">1</span>
<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>kdb<span class="token operator">&gt;</span> go
</code><button class="copy-code-button"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon lucide-copy"><rect x="8" y="8" width="14" height="14" rx="2" ry="2"></rect><path d="M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2"></path></svg></button></pre></div><div class="el-p"><p dir="auto"><code>bp</code> 命令告诉 <code>kdb</code> 在下一次内核进入 <code>scull_read</code> 时停止。然后你输入 <code>go</code> 继续执行。在将某些内容放入其中一个 <code>scull</code> 设备后，我们可以尝试通过在另一个终端上的 shell 下运行 <code>cat</code> 来读取它，结果如下：</p></div><div class="el-pre"><pre class="language-bash" tabindex="0"><code data-line="0" class="language-bash is-loaded">Instruction<span class="token punctuation">(</span>i<span class="token punctuation">)</span> breakpoint <span class="token comment">#0 at 0xd087c5dc (adjusted)</span>
0xd087c5dc scull_read: int3

Entering kdb <span class="token punctuation">(</span>current<span class="token operator">=</span>0xcf09f890, pid <span class="token number">1575</span><span class="token punctuation">)</span> on processor <span class="token number">0</span> due to
Breakpoint @ 0xd087c5dc
<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>kdb<span class="token operator">&gt;</span>
</code><button class="copy-code-button"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon lucide-copy"><rect x="8" y="8" width="14" height="14" rx="2" ry="2"></rect><path d="M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2"></path></svg></button></pre></div><div class="el-p"><p dir="auto">我们现在位于 <code>scull_read</code> 的开头。要查看我们是如何到达那里的，我们可以获取一个栈回溯：</p></div><div class="el-pre"><pre class="language-bash" tabindex="0"><code data-line="0" class="language-bash is-loaded"><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>kdb<span class="token operator">&gt;</span> bt
ESP EIP Function <span class="token punctuation">(</span>args<span class="token punctuation">)</span>
0xcdbddf74 0xd087c5dc <span class="token punctuation">[</span>scull<span class="token punctuation">]</span><span class="token punctuation">[</span>scull_read<span class="token punctuation">]</span>
0xcdbddf78 0xc0150718 vfs_read+0xb8
0xcdbddf4a 0xc01509c2 sys_read+0x42
0xcdbddfca 0xc0103fcf syscall_call+0x7
<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>kdb<span class="token operator">&gt;</span>
</code><button class="copy-code-button"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon lucide-copy"><rect x="8" y="8" width="14" height="14" rx="2" ry="2"></rect><path d="M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2"></path></svg></button></pre></div><div class="el-p"><p dir="auto"><code>kdb</code> 试图打印调用栈中每个函数的参数。然而，它会被编译器使用的优化技巧搞糊涂。因此，它无法打印 <code>scull_read</code> 的参数。</p></div><div class="el-p"><p dir="auto">是时候查看一些数据了。<code>mds</code> 命令操作数据；我们可以使用如下命令查询 <code>scull_devices</code> 指针的值：</p></div><div class="el-pre"><pre class="language-bash" tabindex="0"><code data-line="0" class="language-bash is-loaded"><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>kdb<span class="token operator">&gt;</span> mds scull_devices <span class="token number">1</span>
0xd0880de8 cf36ac00 <span class="token punctuation">..</span>.
</code><button class="copy-code-button"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon lucide-copy"><rect x="8" y="8" width="14" height="14" rx="2" ry="2"></rect><path d="M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2"></path></svg></button></pre></div><div class="el-p"><p dir="auto">在这里，我们要求从 <code>scull_devices</code> 的位置开始的一个（4 字节）字的数据；答案告诉我们，我们的设备数组位于地址 <code>0xd0880de8</code>；第一个设备结构本身位于 <code>0xcf36ac00</code>。要查看该设备结构，我们需要使用该地址：</p></div><div class="el-pre"><pre class="language-bash" tabindex="0"><code data-line="0" class="language-bash is-loaded"><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>kdb<span class="token operator">&gt;</span> mds cf36ac00
0xcf36ac00 ce137dbc <span class="token punctuation">..</span>.
0xcf36ac04 00000fa0 <span class="token punctuation">..</span>.
0xcf36ac08 000003e8 <span class="token punctuation">..</span>.
0xcf36ac0c 0000009b <span class="token punctuation">..</span>.
0xcf36ac10 00000000 <span class="token punctuation">..</span>.
0xcf36ac14 00000001 <span class="token punctuation">..</span>.
0xcf36ac18 00000000 <span class="token punctuation">..</span>.
0xcf36ac1c 00000001 <span class="token punctuation">..</span>.
</code><button class="copy-code-button"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon lucide-copy"><rect x="8" y="8" width="14" height="14" rx="2" ry="2"></rect><path d="M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2"></path></svg></button></pre></div><div class="el-p"><p dir="auto">这里的八行对应于 <code>scull_dev</code> 结构的开头部分。因此，我们看到第一个设备的内存分配在 <code>0xce137dbc</code>，量子大小为 4000（十六进制 <code>fa0</code>），量子集大小为 1000（十六进制 <code>3e8</code>），当前设备中存储了 155（十六进制 <code>9b</code>）字节。</p></div><div class="el-p"><p dir="auto"><code>kdb</code> 也可以更改数据。假设我们想从设备中删除一些数据：</p></div><div class="el-pre"><pre class="language-bash" tabindex="0"><code data-line="0" class="language-bash is-loaded"><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>kdb<span class="token operator">&gt;</span> mm cf36ac0c 0x50
0xcf36ac0c <span class="token operator">=</span> 0x50
</code><button class="copy-code-button"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon lucide-copy"><rect x="8" y="8" width="14" height="14" rx="2" ry="2"></rect><path d="M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2"></path></svg></button></pre></div><div class="el-p"><p dir="auto">随后在设备上运行 <code>cat</code> 将返回比之前更少的数据。</p></div><div class="el-p"><p dir="auto"><code>kdb</code> 还有许多其他功能，包括单步执行（按指令，而不是 C 源代码行）、在数据访问时设置断点、反汇编代码、遍历链表、访问寄存器数据等。应用 <code>kdb</code> 补丁后，你可以在内核源代码树的 <code>Documentation/kdb</code> 目录中找到完整的手册页。</p></div></div></div><div class="el-h2 heading-wrapper"><h2 data-heading="`kgdb` 补丁" dir="auto" class="heading" id="`kgdb`_补丁"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><code>kgdb</code> 补丁</h2><div class="heading-children"><div class="el-p"><p dir="auto">我们到目前为止看到的两种交互式调试方法（在 <code>/proc/kcore</code> 上使用 <code>gdb</code> 和 <code>kdb</code>）都达不到用户空间应用程序开发者所习惯的环境。如果有一个真正的内核调试器支持像修改变量、断点等功能，那不是很好吗？</p></div><div class="el-p"><p dir="auto">事实证明，确实存在这样的解决方案。截至本文撰写时，有两个独立的补丁在流通，它们允许 <code>gdb</code> 以完整功能运行以调试内核。令人困惑的是，这两个补丁都称为 <code>kgdb</code>。它们通过将运行测试内核的系统与运行调试器的系统分开来工作；两者通常通过串行电缆连接。因此，开发者可以在其稳定的桌面系统上运行 <code>gdb</code>，同时操作在测试机器上运行的内核。在这种模式下设置 <code>gdb</code> 需要一些初始时间，但当出现难以解决的错误时，这种投资可以迅速得到回报。</p></div><div class="el-p"><p dir="auto">这些补丁处于快速变化的状态，甚至可能在某个时候合并，因此我们避免对它们进行过多描述，只介绍它们的位置和基本功能。感兴趣的读者可以查看当前的情况。</p></div><div class="el-p"><p dir="auto">第一个 <code>kgdb</code> 补丁目前位于 <code>-mm</code> 内核树中——这是补丁进入 2.6 主线的暂存区。此版本的补丁支持 x86、SuperH、ia64、x86_64、SPARC 和 32 位 PPC 架构。除了通常通过串行端口操作的模式外，此版本的 <code>kgdb</code> 还可以通过局域网进行通信。只需启用以太网模式并使用 <code>kgdboe</code> 参数启动，指示调试命令可以源自的 IP 地址。<code>Documentation/i386/kgdb</code> 下的文档描述了如何设置。[*]</p></div><div class="el-p"><p dir="auto">作为替代方案，你可以使用 <code>http://kgdb.sf.net/</code> 上的 <code>kgdb</code> 补丁。此版本的调试器不支持网络通信模式（尽管据说正在开发中），但它确实有一些内置支持来处理可加载模块。它支持 x86、x86_64、PowerPC 和 S/390 架构。</p></div></div></div><div class="el-h2 heading-wrapper"><h2 data-heading="用户模式 Linux 端口" dir="auto" class="heading" id="用户模式_Linux_端口"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>用户模式 Linux 端口</h2><div class="heading-children"><div class="el-p"><p dir="auto">用户模式 Linux（UML）是一个有趣的概念。它被结构化为 Linux 内核的一个独立端口，拥有自己的 <code>arch/um</code> 子目录。然而，它并不运行在新的硬件类型上；相反，它运行在 Linux 系统调用接口上实现的虚拟机上。因此，UML 允许 Linux 内核作为 Linux 系统上的一个独立的用户模式进程运行。</p></div><div class="el-p"><p dir="auto">将内核作为用户模式进程运行带来了许多优势。由于它在受约束的虚拟处理器上运行，有问题的内核不会损坏“真实”系统。可以轻松地在同一台机器上尝试不同的硬件和软件配置。对于内核开发者来说，最重要的是用户模式内核可以轻松地用 <code>gdb</code> 或其他调试器进行操作。</p></div><div class="el-p"><p dir="auto">然而，UML 对驱动程序开发者有一个很大的缺点：用户模式内核无法访问主机系统的硬件。因此，虽然它可以用于调试本书中的大多数示例驱动程序，但 UML 目前还不能用于调试必须处理真实硬件的驱动程序。</p></div><div class="el-p"><p dir="auto">有关 UML 的更多信息，请参见 <a rel="noopener nofollow" class="external-link" href="http://user-mode-linux.sf.net/" target="_blank">http://user-mode-linux.sf.net/</a>。</p></div></div></div><div class="el-h2 heading-wrapper"><h2 data-heading="Linux 跟踪工具包" dir="auto" class="heading" id="Linux_跟踪工具包"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>Linux 跟踪工具包</h2><div class="heading-children"><div class="el-p"><p dir="auto">Linux 跟踪工具包（LTT）是一个内核补丁和一组相关实用程序，允许跟踪内核中的事件。跟踪包括时间信息，可以创建给定时间段内发生的事件的相当完整的图片。因此，它不仅可以用于调试，还可以用于追踪性能问题。</p></div><div class="el-p"><p dir="auto">LTT 及其详细文档可以在 <a rel="noopener nofollow" class="external-link" href="http://www.opersys.com/LTT" target="_blank">http://www.opersys.com/LTT</a> 找到。</p></div></div></div><div class="el-h2 heading-wrapper"><h2 data-heading="动态探针" dir="auto" class="heading" id="动态探针"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>动态探针</h2><div class="heading-children"><div class="el-p"><p dir="auto">动态探针（DProbes）是 IBM 为 Linux 在 IA-32 架构上发布的调试工具（根据 GPL 发布）。它允许在系统中的几乎任何位置（用户空间和内核空间）放置“探针”。探针由一些代码（用一种专门的、基于堆栈的语言编写）组成，当控制到达给定点时执行。此代码可以向用户空间报告信息、更改寄存器或执行许多其他操作。DProbes 的有用特性是，一旦该功能被构建到内核中，探针可以在运行系统中插入任何位置，而无需内核构建或重新启动。DProbes 还可以与 LTT 一起工作，以在任意位置插入新的跟踪事件。</p></div><div class="el-p"><p dir="auto">DProbes 工具可以从 IBM 的开源站点下载：<a rel="noopener nofollow" class="external-link" href="http://oss.software.ibm.com" target="_blank">http://oss.software.ibm.com</a>。</p></div><div class="el-hr"><hr></div></div></div><div class="el-h2 heading-wrapper"><h2 data-heading="总结" dir="auto" class="heading" id="总结"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>总结</h2><div class="heading-children"><div class="el-p"><p dir="auto">本章介绍了多种调试内核代码的技术，从简单的打印语句到复杂的调试器和跟踪工具。每种方法都有其优缺点，开发者应根据具体情况选择最合适的工具。通过熟练掌握这些调试技术，你可以更有效地解决内核开发中的问题，并提高代码的稳定性和性能。</p></div><div class="mod-footer mod-ui"></div></div></div></div></div></div><div class="sidebar-right sidebar"><div class="sidebar-handle"></div><div class="sidebar-topbar"><div class="topbar-content"></div><div class="clickable-icon sidebar-collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="100%" height="100%" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="3" stroke-linecap="round" stroke-linejoin="round" class="svg-icon"><path d="M21 3H3C1.89543 3 1 3.89543 1 5V19C1 20.1046 1.89543 21 3 21H21C22.1046 21 23 20.1046 23 19V5C23 3.89543 22.1046 3 21 3Z"></path><path d="M10 4V20"></path><path d="M4 7H7"></path><path d="M4 10H7"></path><path d="M4 13H7"></path></svg></div></div><div class="sidebar-content"><div class="graph-view-wrapper"><div class="sidebar-section-header">Interactive Graph</div><div class="graph-view-placeholder">
		<div class="graph-view-container">
			<div class="graph-icon graph-expand" role="button" aria-label="Expand" data-tooltip-position="top"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon"><line x1="7" y1="17" x2="17" y2="7"></line><polyline points="7 7 17 7 17 17"></polyline></svg></div>
			<canvas id="graph-canvas" class="hide" width="512px" height="512px"></canvas>
		</div>
		</div></div><div class="tree-container mod-root nav-folder tree-item outline-tree" data-depth="0"><div class="tree-header"><span class="sidebar-section-header">Table Of Contents</span><button class="clickable-icon collapse-tree-button" aria-label="Collapse All"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"></svg></button></div><div class="tree-scroll-area tree-item-children nav-folder-children"><div class="tree-item mod-tree-folder nav-folder mod-collapsible is-collapsed" style="display: none;"></div><div class="tree-item" data-depth="1"><a class="tree-link" href="第4章-调试技术/4.6-调试器及相关工具.html#4.6  调试器及相关工具"><div class="tree-item-contents heading-link" heading-name="4.6  调试器及相关工具"><span class="tree-item-title">4.6  调试器及相关工具</span></div></a><div class="tree-item-children nav-folder-children"><div class="tree-item" data-depth="2"><a class="tree-link" href="第4章-调试技术/4.6-调试器及相关工具.html#使用_`gdb`"><div class="tree-item-contents heading-link" heading-name="使用 `gdb`"><span class="tree-item-title">使用 <code>gdb</code></span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="2"><a class="tree-link" href="第4章-调试技术/4.6-调试器及相关工具.html#`kdb`_内核调试器"><div class="tree-item-contents heading-link" heading-name="`kdb` 内核调试器"><span class="tree-item-title"><code>kdb</code> 内核调试器</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="2"><a class="tree-link" href="第4章-调试技术/4.6-调试器及相关工具.html#`kgdb`_补丁"><div class="tree-item-contents heading-link" heading-name="`kgdb` 补丁"><span class="tree-item-title"><code>kgdb</code> 补丁</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="2"><a class="tree-link" href="第4章-调试技术/4.6-调试器及相关工具.html#用户模式_Linux_端口"><div class="tree-item-contents heading-link" heading-name="用户模式 Linux 端口"><span class="tree-item-title">用户模式 Linux 端口</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="2"><a class="tree-link" href="第4章-调试技术/4.6-调试器及相关工具.html#Linux_跟踪工具包"><div class="tree-item-contents heading-link" heading-name="Linux 跟踪工具包"><span class="tree-item-title">Linux 跟踪工具包</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="2"><a class="tree-link" href="第4章-调试技术/4.6-调试器及相关工具.html#动态探针"><div class="tree-item-contents heading-link" heading-name="动态探针"><span class="tree-item-title">动态探针</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="2"><a class="tree-link" href="第4章-调试技术/4.6-调试器及相关工具.html#总结"><div class="tree-item-contents heading-link" heading-name="总结"><span class="tree-item-title">总结</span></div></a><div class="tree-item-children nav-folder-children"></div></div></div></div></div></div></div><script defer="">let rs = document.querySelector(".sidebar-right"); rs.classList.add("is-collapsed"); if (window.innerWidth > 768) rs.classList.remove("is-collapsed"); rs.style.setProperty("--sidebar-width", localStorage.getItem("sidebar-right-width"));</script></div></div></body></html>
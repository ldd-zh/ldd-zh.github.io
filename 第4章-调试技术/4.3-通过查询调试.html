<!DOCTYPE html> <html><head>
		<title>4.3 通过查询调试</title>
		<base href="../">
		<meta id="root-path" root-path="../">
		<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes, minimum-scale=1.0, maximum-scale=5.0">
		<meta charset="UTF-8">
		<meta name="description" content="ldd_zh - 4.3 通过查询调试">
		<meta property="og:title" content="4.3 通过查询调试">
		<meta property="og:description" content="ldd_zh - 4.3 通过查询调试">
		<meta property="og:type" content="website">
		<meta property="og:url" content="第4章-调试技术/4.3-通过查询调试.html">
		<meta property="og:image" content="undefined">
		<meta property="og:site_name" content="ldd_zh">
		<link rel="alternate" type="application/rss+xml" title="RSS Feed" href="lib/rss.xml"><script async="" id="webpage-script" src="lib/scripts/webpage.js" onload="this.onload=null;this.setAttribute(&quot;loaded&quot;, &quot;true&quot;)"></script><script type="module" async="" id="graph-view-script" src="lib/scripts/graph-view.js"></script><script async="" id="graph-wasm-script" src="lib/scripts/graph-wasm.js" onload="this.onload=null;this.setAttribute(&quot;loaded&quot;, &quot;true&quot;)"></script><script async="" id="graph-render-worker-script" src="lib/scripts/graph-render-worker.js" onload="this.onload=null;this.setAttribute(&quot;loaded&quot;, &quot;true&quot;)"></script><script async="" id="tinycolor-script" src="lib/scripts/tinycolor.js" onload="this.onload=null;this.setAttribute(&quot;loaded&quot;, &quot;true&quot;)"></script><script async="" id="pixi-script" src="https://cdnjs.cloudflare.com/ajax/libs/pixi.js/7.4.0/pixi.min.js" onload="this.onload=null;this.setAttribute(&quot;loaded&quot;, &quot;true&quot;)"></script><script async="" id="minisearch-script" src="https://cdn.jsdelivr.net/npm/minisearch@6.3.0/dist/umd/index.min.js" onload="this.onload=null;this.setAttribute(&quot;loaded&quot;, &quot;true&quot;)"></script><link rel="icon" href="lib/media/favicon.png"><script async="" id="graph-data-script" src="lib/scripts/graph-data.js" onload="this.onload=null;this.setAttribute(&quot;loaded&quot;, &quot;true&quot;)"></script><style>body{--line-width:40em;--line-width-adaptive:40em;--file-line-width:40em;--sidebar-width:min(20em, 80vw);--collapse-arrow-size:11px;--tree-horizontal-spacing:0.6em;--tree-vertical-spacing:0.6em;--sidebar-margin:12px}.sidebar{height:100%;min-width:calc(var(--sidebar-width) + var(--divider-width-hover));max-width:calc(var(--sidebar-width) + var(--divider-width-hover));font-size:14px;z-index:10;position:relative;overflow:hidden;transition:min-width ease-in-out,max-width ease-in-out;transition-duration:.2s;contain:size}.sidebar-left{left:0}.sidebar-right{right:0}.sidebar.is-collapsed{min-width:0;max-width:0}body.floating-sidebars .sidebar{position:absolute}.sidebar-content{height:100%;min-width:calc(var(--sidebar-width) - var(--divider-width-hover));top:0;padding:var(--sidebar-margin);padding-top:4em;line-height:var(--line-height-tight);background-color:var(--background-secondary);transition:background-color,border-right,border-left,box-shadow;transition-duration:var(--color-fade-speed);transition-timing-function:ease-in-out;position:absolute;display:flex;flex-direction:column}.sidebar:not(.is-collapsed) .sidebar-content{min-width:calc(max(100%,var(--sidebar-width)) - 3px);max-width:calc(max(100%,var(--sidebar-width)) - 3px)}.sidebar-left .sidebar-content{left:0;border-top-right-radius:var(--radius-l);border-bottom-right-radius:var(--radius-l)}.sidebar-right .sidebar-content{right:0;border-top-left-radius:var(--radius-l);border-bottom-left-radius:var(--radius-l)}.sidebar:has(.sidebar-content:empty):has(.topbar-content:empty){display:none}.sidebar-topbar{height:2em;width:var(--sidebar-width);top:var(--sidebar-margin);padding-inline:var(--sidebar-margin);z-index:1;position:fixed;display:flex;align-items:center;transition:width ease-in-out;transition-duration:inherit}.sidebar.is-collapsed .sidebar-topbar{width:calc(2.3em + var(--sidebar-margin) * 2)}.sidebar .sidebar-topbar.is-collapsed{width:0}.sidebar-left .sidebar-topbar{left:0}.sidebar-right .sidebar-topbar{right:0}.topbar-content{overflow:hidden;overflow:clip;width:100%;height:100%;display:flex;align-items:center;transition:inherit}.sidebar.is-collapsed .topbar-content{width:0;transition:inherit}.clickable-icon.sidebar-collapse-icon{background-color:transparent;color:var(--icon-color-focused);padding:0!important;margin:0!important;height:100%!important;width:2.3em!important;margin-inline:0.14em!important;position:absolute}.sidebar-left .clickable-icon.sidebar-collapse-icon{transform:rotateY(180deg);right:var(--sidebar-margin)}.sidebar-right .clickable-icon.sidebar-collapse-icon{transform:rotateY(180deg);left:var(--sidebar-margin)}.clickable-icon.sidebar-collapse-icon svg.svg-icon{width:100%;height:100%}.sidebar-section-header{margin:0 0 1em 0;text-transform:uppercase;letter-spacing:.06em;font-weight:600}body{transition:background-color var(--color-fade-speed) ease-in-out}.webpage-container{display:flex;flex-direction:row;height:100%;width:100%;align-items:stretch;justify-content:center}.document-container{opacity:1;flex-basis:100%;max-width:100%;width:100%;height:100%;display:flex;flex-direction:column;align-items:center;transition:opacity .2s ease-in-out;contain:inline-size}.hide{opacity:0;transition:opacity .2s ease-in-out}.document-container>.markdown-preview-view{margin:var(--sidebar-margin);margin-bottom:0;width:100%;width:-webkit-fill-available;width:-moz-available;width:fill-available;background-color:var(--background-primary);transition:background-color var(--color-fade-speed) ease-in-out;border-top-right-radius:var(--window-radius,var(--radius-m));border-top-left-radius:var(--window-radius,var(--radius-m));overflow-x:hidden!important;overflow-y:auto!important;display:flex!important;flex-direction:column!important;align-items:center!important;contain:inline-size}.document-container>.markdown-preview-view>.markdown-preview-sizer{padding-bottom:80vh!important;width:100%!important;max-width:var(--line-width)!important;flex-basis:var(--line-width)!important;transition:background-color var(--color-fade-speed) ease-in-out;contain:inline-size}.markdown-rendered img:not([width]),.view-content img:not([width]){max-width:100%;outline:0}.document-container>.view-content.embed{display:flex;padding:1em;height:100%;width:100%;align-items:center;justify-content:center}.document-container>.view-content.embed>*{max-width:100%;max-height:100%;object-fit:contain}:has(> :is(.math,table)){overflow-x:auto!important}.document-container>.view-content{overflow-x:auto;contain:content;padding:0;margin:0;height:100%}.scroll-highlight{position:absolute;width:100%;height:100%;pointer-events:none;z-index:1000;background-color:hsla(var(--color-accent-hsl),.25);opacity:0;padding:1em;inset:50%;translate:-50% -50%;border-radius:var(--radius-s)}</style><script defer="">async function loadIncludes(){if("file:"!=location.protocol){let e=document.querySelectorAll("include");for(let t=0;t<e.length;t++){let o=e[t],l=o.getAttribute("src");try{const e=await fetch(l);if(!e.ok){console.log("Could not include file: "+l),o?.remove();continue}let t=await e.text(),n=document.createRange().createContextualFragment(t),i=Array.from(n.children);for(let e of i)e.classList.add("hide"),e.style.transition="opacity 0.5s ease-in-out",setTimeout((()=>{e.classList.remove("hide")}),10);o.before(n),o.remove(),console.log("Included file: "+l)}catch(e){o?.remove(),console.log("Could not include file: "+l,e);continue}}}else{if(document.querySelectorAll("include").length>0){var e=document.createElement("div");e.id="error",e.textContent="Web server exports must be hosted on an http / web server to be viewed correctly.",e.style.position="fixed",e.style.top="50%",e.style.left="50%",e.style.transform="translate(-50%, -50%)",e.style.fontSize="1.5em",e.style.fontWeight="bold",e.style.textAlign="center",document.body.appendChild(e),document.querySelector(".document-container")?.classList.remove("hide")}}}document.addEventListener("DOMContentLoaded",(()=>{loadIncludes()}));let isFileProtocol="file:"==location.protocol;function waitLoadScripts(e,t){let o=e.map((e=>document.getElementById(e+"-script"))),l=0;!function e(){let n=o[l];l++,n&&"true"!=n.getAttribute("loaded")||l<o.length&&e(),l<o.length?n.addEventListener("load",e):t()}()}</script><link rel="stylesheet" href="lib/styles/obsidian.css"><link rel="stylesheet" href="lib/styles/theme.css"><link rel="preload" href="lib/styles/global-variable-styles.css" as="style" onload="this.onload=null;this.rel='stylesheet'"><noscript><link rel="stylesheet" href="lib/styles/global-variable-styles.css"></noscript><link rel="preload" href="lib/styles/main-styles.css" as="style" onload="this.onload=null;this.rel='stylesheet'"><noscript><link rel="stylesheet" href="lib/styles/main-styles.css"></noscript></head><body class="publish css-settings-manager native-scrollbars theme-light show-inline-title show-ribbon"><script defer="">let theme=localStorage.getItem("theme")||(window.matchMedia("(prefers-color-scheme: dark)").matches?"dark":"light");"dark"==theme?(document.body.classList.add("theme-dark"),document.body.classList.remove("theme-light")):(document.body.classList.add("theme-light"),document.body.classList.remove("theme-dark")),window.innerWidth<480?document.body.classList.add("is-phone"):window.innerWidth<768?document.body.classList.add("is-tablet"):window.innerWidth<1024?document.body.classList.add("is-small-screen"):document.body.classList.add("is-large-screen")</script><div class="webpage-container workspace"><div class="sidebar-left sidebar"><div class="sidebar-handle"></div><div class="sidebar-topbar"><div class="topbar-content"><label class="theme-toggle-container" for="theme_toggle"><input class="theme-toggle-input" type="checkbox" id="theme_toggle"><div class="toggle-background"></div></label></div><div class="clickable-icon sidebar-collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="100%" height="100%" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="3" stroke-linecap="round" stroke-linejoin="round" class="svg-icon"><path d="M21 3H3C1.89543 3 1 3.89543 1 5V19C1 20.1046 1.89543 21 3 21H21C22.1046 21 23 20.1046 23 19V5C23 3.89543 22.1046 3 21 3Z"></path><path d="M10 4V20"></path><path d="M4 7H7"></path><path d="M4 10H7"></path><path d="M4 13H7"></path></svg></div></div><div class="sidebar-content"><div class="search-input-container"><input enterkeyhint="search" type="search" spellcheck="false" placeholder="Search..."><div class="search-input-clear-button" aria-label="Clear search"></div></div><include src="lib/html/file-tree.html"></include></div><script defer="">let ls = document.querySelector(".sidebar-left"); ls.classList.add("is-collapsed"); if (window.innerWidth > 768) ls.classList.remove("is-collapsed"); ls.style.setProperty("--sidebar-width", localStorage.getItem("sidebar-left-width"));</script></div><div class="document-container markdown-reading-view hide"><div class="markdown-preview-view markdown-rendered allow-fold-headings allow-fold-lists is-readable-line-width"><style id="MJX-CHTML-styles"></style><div class="markdown-preview-sizer markdown-preview-section"><h1 class="page-title heading inline-title" id="4.3 通过查询调试">4.3 通过查询调试</h1><div class="el-p"><p dir="auto">上一节描述了 <code>printk</code> 的工作原理及其使用方法。但它没有讨论它的缺点。</p></div><div class="el-p"><p dir="auto">大量使用 <code>printk</code> 会显著减慢系统速度，即使你降低 <code>console_loglevel</code> 以避免加载控制台设备，因为 <code>syslogd</code> 会不断同步其输出文件；因此，打印的每一行都会导致磁盘操作。从 <code>syslogd</code> 的角度来看，这是正确的实现。它试图将所有内容写入磁盘，以防系统在打印消息后立即崩溃；然而，你不希望仅仅为了调试消息而减慢系统速度。这个问题可以通过在 <code>/etc/syslog.conf</code> 中的日志文件名前加上连字符来解决。修改配置文件的问题是，调试完成后，修改可能会保留在那里，尽管在正常系统操作期间你希望消息尽快刷新到磁盘。另一种替代方法是运行 <code>klogd</code> 以外的程序（例如之前建议的 <code>cat /proc/kmsg</code>），但这可能无法为正常系统操作提供合适的环境。</p></div><div class="el-p"><p dir="auto">通常情况下，获取相关信息的最佳方法是在需要时查询系统，而不是不断生成数据。事实上，每个 Unix 系统都提供了许多工具来获取系统信息：<code>ps</code>、<code>netstat</code>、<code>vmstat</code> 等。</p></div><div class="el-p"><p dir="auto">驱动程序开发者有几种技术可以查询系统：在 <code>/proc</code> 文件系统中创建文件、使用 <code>ioctl</code> 驱动程序方法以及通过 <code>sysfs</code> 导出属性。使用 <code>sysfs</code> 需要相当多的驱动程序模型背景。我们将在第 14 章讨论它。</p></div><div class="el-h2 heading-wrapper"><h2 data-heading="使用 `/proc` 文件系统" dir="auto" class="heading" id="使用_`/proc`_文件系统"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>使用 <code>/proc</code> 文件系统</h2><div class="heading-children"><div class="el-p"><p dir="auto"><code>/proc</code> 文件系统是一个特殊的、由软件创建的文件系统，内核用它来向外界导出信息。<code>/proc</code> 下的每个文件都与一个内核函数相关联，该函数在文件被读取时动态生成文件的内容。我们已经看到了一些这样的文件在运行；例如，<code>/proc/modules</code> 总是返回当前加载的模块列表。</p></div><div class="el-p"><p dir="auto"><code>/proc</code> 在 Linux 系统中被广泛使用。现代 Linux 发行版上的许多实用程序，如 <code>ps</code>、<code>top</code> 和 <code>uptime</code>，都从 <code>/proc</code> 获取信息。一些设备驱动程序也通过 <code>/proc</code> 导出信息，你的驱动程序也可以这样做。<code>/proc</code> 文件系统是动态的，因此你的模块可以随时添加或删除条目。</p></div><div class="el-p"><p dir="auto">功能齐全的 <code>/proc</code> 条目可能非常复杂；除了其他功能外，它们还可以被写入和读取。大多数情况下，<code>/proc</code> 条目是只读文件。本节关注的是简单的只读情况。那些对实现更复杂功能感兴趣的人可以在这里找到基础知识；然后可以查阅内核源代码以获取完整的信息。</p></div><div class="el-p"><p dir="auto">在继续之前，我们应该提到，不鼓励在 <code>/proc</code> 下添加文件。内核开发者认为 <code>/proc</code> 文件系统有点失控，已经远远超出了其原始目的（即提供系统中运行的进程的信息）。在新代码中提供信息的推荐方式是通过 <code>sysfs</code>。正如前面提到的，使用 <code>sysfs</code> 需要理解 Linux 设备模型，我们直到第 14 章才会讨论它。与此同时，<code>/proc</code> 下的文件稍微容易创建，并且完全适合调试目的，因此我们在这里介绍它们。</p></div><div class="el-h3 heading-wrapper"><h3 data-heading="在 `/proc` 中实现文件" dir="auto" class="heading" id="在_`/proc`_中实现文件"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>在 <code>/proc</code> 中实现文件</h3><div class="heading-children"><div class="el-p"><p dir="auto">所有与 <code>/proc</code> 一起工作的模块都应包含 <code>&lt;linux/proc_fs.h&gt;</code> 以定义适当的函数。</p></div><div class="el-p"><p dir="auto">要创建一个只读的 <code>/proc</code> 文件，你的驱动程序必须实现一个函数，在文件被读取时生成数据。当某个进程读取文件（使用 <code>read</code> 系统调用）时，请求通过此函数到达你的模块。我们将首先查看此函数，然后在本节后面讨论注册接口。</p></div><div class="el-p"><p dir="auto">当进程从你的 <code>/proc</code> 文件读取时，内核会分配一页内存（即 <code>PAGE_SIZE</code> 字节），驱动程序可以将数据写入该内存以返回给用户空间。该缓冲区会传递给你的函数，该函数是一个名为 <code>read_proc</code> 的方法：</p></div><div class="el-pre"><pre class="language-c" tabindex="0"><code data-line="0" class="language-c is-loaded"><span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span>read_proc<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span>page<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span><span class="token operator">*</span>start<span class="token punctuation">,</span> <span class="token class-name">off_t</span> offset<span class="token punctuation">,</span> <span class="token keyword">int</span> count<span class="token punctuation">,</span> <span class="token keyword">int</span> <span class="token operator">*</span>eof<span class="token punctuation">,</span> <span class="token keyword">void</span> <span class="token operator">*</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code><button class="copy-code-button"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon lucide-copy"><rect x="8" y="8" width="14" height="14" rx="2" ry="2"></rect><path d="M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2"></path></svg></button></pre></div><div class="el-p"><p dir="auto"><code>page</code> 指针是你将写入数据的缓冲区；<code>start</code> 由函数用于指示在 <code>page</code> 中写入了有趣数据的位置（稍后会详细介绍）；<code>offset</code> 和 <code>count</code> 的含义与 <code>read</code> 方法相同。<code>eof</code> 参数指向一个整数，驱动程序必须设置该整数以表示没有更多数据要返回，而 <code>data</code> 是一个驱动程序特定的数据指针，你可以用于内部簿记。</p></div><div class="el-p"><p dir="auto">此函数应返回实际放置在 <code>page</code> 缓冲区中的数据字节数，就像其他文件的 <code>read</code> 方法一样。其他输出值是 <code>eof</code> 和 <code>start</code>。<code>eof</code> 是一个简单的标志，但 <code>start</code> 值的用途稍微复杂一些；其目的是帮助实现大于一页的 <code>/proc</code> 文件。</p></div><div class="el-p"><p dir="auto"><code>start</code> 参数的使用有些非传统。其目的是指示在 <code>page</code> 中返回给用户的数据的位置。当你的 <code>proc_read</code> 方法被调用时，<code>*start</code> 将为 <code>NULL</code>。如果你将其保留为 <code>NULL</code>，内核会假定数据已按 <code>offset</code> 为 0 的方式放入 <code>page</code> 中；换句话说，它假定一个简单的 <code>proc_read</code> 版本，该版本将虚拟文件的全部内容放入 <code>page</code> 中，而不考虑 <code>offset</code> 参数。相反，如果你将 <code>*start</code> 设置为非 <code>NULL</code> 值，内核会假定 <code>*start</code> 指向的数据考虑了 <code>offset</code>，并准备直接返回给用户。通常，返回少量数据的简单 <code>proc_read</code> 方法会忽略 <code>start</code>。更复杂的方法将 <code>*start</code> 设置为 <code>page</code>，并仅将数据从请求的偏移量开始放置在那里。</p></div><div class="el-p"><p dir="auto">长期以来，<code>/proc</code> 文件还存在另一个主要问题，<code>start</code> 也旨在解决这个问题。有时，内核数据结构的 ASCII 表示在连续的 <code>read</code> 调用之间会发生变化，因此读取进程可能会发现从一个调用到下一个调用的数据不一致。如果 <code>*start</code> 设置为一个小的整数值，调用者会使用它来独立于你返回的数据量递增 <code>flip-&gt;f_pos</code>，从而使 <code>f_pos</code> 成为你的 <code>read_proc</code> 过程的内部记录号。例如，如果你的 <code>read_proc</code> 函数从一个大的结构数组中返回信息，并且在第一次调用中返回了五个结构，<code>*start</code> 可以设置为 5。下一次调用会提供相同的值作为偏移量；驱动程序然后知道从数组中的第六个结构开始返回数据。这被其作者承认是一个“hack”，可以在 <code>fs/proc/generic.c</code> 中看到。</p></div><div class="el-p"><p dir="auto">请注意，实现大型 <code>/proc</code> 文件有更好的方法；它被称为 <code>seq_file</code>，我们稍后会讨论它。首先，我们来看一个示例。以下是 <code>scull</code> 设备的一个简单（虽然有点丑陋）的 <code>read_proc</code> 实现：</p></div><div class="el-pre"><pre class="language-c" tabindex="0"><code data-line="0" class="language-c is-loaded"><span class="token keyword">int</span> <span class="token function">scull_read_procmem</span><span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span>buf<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span><span class="token operator">*</span>start<span class="token punctuation">,</span> <span class="token class-name">off_t</span> offset<span class="token punctuation">,</span>
    <span class="token keyword">int</span> count<span class="token punctuation">,</span> <span class="token keyword">int</span> <span class="token operator">*</span>eof<span class="token punctuation">,</span> <span class="token keyword">void</span> <span class="token operator">*</span>data<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">int</span> i<span class="token punctuation">,</span> j<span class="token punctuation">,</span> len <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> limit <span class="token operator">=</span> count <span class="token operator">-</span> <span class="token number">80</span><span class="token punctuation">;</span> <span class="token comment">/* 不要打印超过这个值 */</span>

    <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> scull_nr_devs <span class="token operator">&amp;&amp;</span> len <span class="token operator">&lt;=</span> limit<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">struct</span> <span class="token class-name">scull_dev</span> <span class="token operator">*</span>d <span class="token operator">=</span> <span class="token operator">&amp;</span>scull_devices<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token keyword">struct</span> <span class="token class-name">scull_qset</span> <span class="token operator">*</span>qs <span class="token operator">=</span> d<span class="token operator">-&gt;</span>data<span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">down_interruptible</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>d<span class="token operator">-&gt;</span>sem<span class="token punctuation">)</span><span class="token punctuation">)</span>
            <span class="token keyword">return</span> <span class="token operator">-</span>ERESTARTSYS<span class="token punctuation">;</span>
        len <span class="token operator">+=</span> <span class="token function">sprintf</span><span class="token punctuation">(</span>buf<span class="token operator">+</span>len<span class="token punctuation">,</span> <span class="token string">"\nDevice %i: qset %i, q %i, sz %li\n"</span><span class="token punctuation">,</span>
            i<span class="token punctuation">,</span> d<span class="token operator">-&gt;</span>qset<span class="token punctuation">,</span> d<span class="token operator">-&gt;</span>quantum<span class="token punctuation">,</span> d<span class="token operator">-&gt;</span>size<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span>j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> qs <span class="token operator">&amp;&amp;</span> len <span class="token operator">&lt;=</span> limit<span class="token punctuation">;</span> qs <span class="token operator">=</span> qs<span class="token operator">-&gt;</span>next<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">/* 扫描列表 */</span>
            len <span class="token operator">+=</span> <span class="token function">sprintf</span><span class="token punctuation">(</span>buf <span class="token operator">+</span> len<span class="token punctuation">,</span> <span class="token string">" item at %p, qset at %p\n"</span><span class="token punctuation">,</span>
                qs<span class="token punctuation">,</span> qs<span class="token operator">-&gt;</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>qs<span class="token operator">-&gt;</span>data <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>qs<span class="token operator">-&gt;</span>next<span class="token punctuation">)</span> <span class="token comment">/* 仅转储最后一项 */</span>
                <span class="token keyword">for</span> <span class="token punctuation">(</span>j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> d<span class="token operator">-&gt;</span>qset<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                    <span class="token keyword">if</span> <span class="token punctuation">(</span>qs<span class="token operator">-&gt;</span>data<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span>
                        len <span class="token operator">+=</span> <span class="token function">sprintf</span><span class="token punctuation">(</span>buf <span class="token operator">+</span> len<span class="token punctuation">,</span>
                            <span class="token string">" % 4i: %8p\n"</span><span class="token punctuation">,</span>
                            j<span class="token punctuation">,</span> qs<span class="token operator">-&gt;</span>data<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
        <span class="token function">up</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>scull_devices<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>sem<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token operator">*</span>eof <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> len<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code><button class="copy-code-button"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon lucide-copy"><rect x="8" y="8" width="14" height="14" rx="2" ry="2"></rect><path d="M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2"></path></svg></button></pre></div><div class="el-p"><p dir="auto">这是一个相当典型的 <code>read_proc</code> 实现。它假定永远不会需要生成超过一页的数据，因此忽略了 <code>start</code> 和 <code>offset</code> 值。然而，它小心地不溢出其缓冲区，以防万一。</p></div></div></div><div class="el-h3 heading-wrapper"><h3 data-heading="旧接口" dir="auto" class="heading" id="旧接口"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>旧接口</h3><div class="heading-children"><div class="el-p"><p dir="auto">如果你阅读内核源代码，你可能会遇到使用旧接口实现 <code>/proc</code> 文件的代码：</p></div><div class="el-pre"><pre class="language-c" tabindex="0"><code data-line="0" class="language-c is-loaded"><span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span>get_info<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span>page<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span><span class="token operator">*</span>start<span class="token punctuation">,</span> <span class="token class-name">off_t</span> offset<span class="token punctuation">,</span> <span class="token keyword">int</span> count<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code><button class="copy-code-button"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon lucide-copy"><rect x="8" y="8" width="14" height="14" rx="2" ry="2"></rect><path d="M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2"></path></svg></button></pre></div><div class="el-p"><p dir="auto">所有参数的含义与 <code>read_proc</code> 相同，但缺少 <code>eof</code> 和 <code>data</code> 参数。此接口仍然受支持，但未来可能会消失；新代码应改用 <code>read_proc</code> 接口。</p></div></div></div><div class="el-h3 heading-wrapper"><h3 data-heading="创建你的 `/proc` 文件" dir="auto" class="heading" id="创建你的_`/proc`_文件"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>创建你的 <code>/proc</code> 文件</h3><div class="heading-children"><div class="el-p"><p dir="auto">一旦你定义了一个 <code>read_proc</code> 函数，你需要将其连接到 <code>/proc</code> 层次结构中的一个条目。这是通过调用 <code>create_proc_read_entry</code> 来完成的：</p></div><div class="el-pre"><pre class="language-c" tabindex="0"><code data-line="0" class="language-c is-loaded"><span class="token keyword">struct</span> <span class="token class-name">proc_dir_entry</span> <span class="token operator">*</span><span class="token function">create_proc_read_entry</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>name<span class="token punctuation">,</span>
    <span class="token class-name">mode_t</span> mode<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">proc_dir_entry</span> <span class="token operator">*</span>base<span class="token punctuation">,</span>
    <span class="token class-name">read_proc_t</span> <span class="token operator">*</span>read_proc<span class="token punctuation">,</span> <span class="token keyword">void</span> <span class="token operator">*</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code><button class="copy-code-button"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon lucide-copy"><rect x="8" y="8" width="14" height="14" rx="2" ry="2"></rect><path d="M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2"></path></svg></button></pre></div><div class="el-p"><p dir="auto">这里，<code>name</code> 是要创建的文件的名称，<code>mode</code> 是文件的保护掩码（可以传递 0 以使用系统范围的默认值），<code>base</code> 指示文件应创建的目录（如果 <code>base</code> 为 <code>NULL</code>，则文件在 <code>/proc</code> 根目录中创建），<code>read_proc</code> 是实现文件的 <code>read_proc</code> 函数，<code>data</code> 被内核忽略（但传递给 <code>read_proc</code>）。以下是 <code>scull</code> 用于使其 <code>/proc</code> 函数作为 <code>/proc/scullmem</code> 可用的调用：</p></div><div class="el-pre"><pre class="language-c" tabindex="0"><code data-line="0" class="language-c is-loaded"><span class="token function">create_proc_read_entry</span><span class="token punctuation">(</span><span class="token string">"scullmem"</span><span class="token punctuation">,</span> <span class="token number">0</span> <span class="token comment">/* 默认模式 */</span><span class="token punctuation">,</span>
    <span class="token constant">NULL</span> <span class="token comment">/* 父目录 */</span><span class="token punctuation">,</span> scull_read_procmem<span class="token punctuation">,</span>
    <span class="token constant">NULL</span> <span class="token comment">/* 客户端数据 */</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code><button class="copy-code-button"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon lucide-copy"><rect x="8" y="8" width="14" height="14" rx="2" ry="2"></rect><path d="M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2"></path></svg></button></pre></div><div class="el-p"><p dir="auto">在这里，我们在 <code>/proc</code> 下直接创建了一个名为 <code>scullmem</code> 的文件，具有默认的、全局可读的保护。</p></div><div class="el-p"><p dir="auto">目录条目指针可用于在 <code>/proc</code> 下创建整个目录层次结构。请注意，条目可以更容易地放置在 <code>/proc</code> 的子目录中，只需在条目名称中给出目录名称——只要目录本身已经存在。例如，一个（经常被忽略的）约定说，与设备驱动程序相关的 <code>/proc</code> 条目应放在 <code>drivers/</code> 子目录中，<code>scull</code> 可以通过将其名称指定为 <code>drivers/scullmem</code> 将其条目放在那里。</p></div><div class="el-p"><p dir="auto">当然，<code>/proc</code> 中的条目应在模块卸载时删除。<code>remove_proc_entry</code> 是撤销 <code>create_proc_read_entry</code> 所做操作的函数：</p></div><div class="el-pre"><pre class="language-c" tabindex="0"><code data-line="0" class="language-c is-loaded"><span class="token function">remove_proc_entry</span><span class="token punctuation">(</span><span class="token string">"scullmem"</span><span class="token punctuation">,</span> <span class="token constant">NULL</span> <span class="token comment">/* 父目录 */</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code><button class="copy-code-button"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon lucide-copy"><rect x="8" y="8" width="14" height="14" rx="2" ry="2"></rect><path d="M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2"></path></svg></button></pre></div><div class="el-p"><p dir="auto">未能删除条目可能会导致在不希望的时间调用，或者如果你的模块已卸载，可能会导致内核崩溃。</p></div><div class="el-p"><p dir="auto">使用 <code>/proc</code> 文件时，你必须记住实现中的一些麻烦——难怪现在不鼓励使用它。</p></div><div class="el-p"><p dir="auto">最重要的问题是与删除 <code>/proc</code> 条目有关。这种删除很可能在文件正在使用时发生，因为 <code>/proc</code> 条目没有所有者，因此使用它们不会影响模块的引用计数。这个问题可以通过在删除模块之前运行 <code>sleep 100 &lt; /proc/myfile</code> 来简单地触发。</p></div><div class="el-p"><p dir="auto">另一个问题与注册两个同名的条目有关。内核信任驱动程序，不会检查名称是否已注册，因此如果你不小心，可能会以相同的名称注册两个或多个条目。这是一个在课堂上已知会发生的问题，这些条目在访问时和调用 <code>remove_proc_entry</code> 时都是不可区分的。</p></div></div></div><div class="el-h3 heading-wrapper"><h3 data-heading="`seq_file` 接口" dir="auto" class="heading" id="`seq_file`_接口"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><code>seq_file</code> 接口</h3><div class="heading-children"><div class="el-p"><p dir="auto">正如我们上面提到的，在 <code>/proc</code> 下实现大文件有点尴尬。随着时间的推移，当输出量变大时，<code>/proc</code> 方法的实现以错误著称。为了清理 <code>/proc</code> 代码并使内核程序员的生活更轻松，添加了 <code>seq_file</code> 接口。该接口提供了一组简单的函数来实现大型内核虚拟文件。</p></div><div class="el-p"><p dir="auto"><code>seq_file</code> 接口假定你正在创建一个虚拟文件，该文件逐步遍历必须返回给用户空间的项目序列。要使用 <code>seq_file</code>，你必须创建一个简单的“迭代器”对象，该对象可以在序列中建立位置、向前移动并输出序列中的一个项目。听起来可能很复杂，但实际上过程相当简单。我们将通过创建 <code>scull</code> 驱动程序中的 <code>/proc</code> 文件来展示它是如何完成的。</p></div><div class="el-p"><p dir="auto">第一步，不可避免地是包含 <code>&lt;linux/seq_file.h&gt;</code>。然后你必须创建四个迭代器方法，称为 <code>start</code>、<code>next</code>、<code>stop</code> 和 <code>show</code>。</p></div><div class="el-p"><p dir="auto"><code>start</code> 方法总是首先被调用。此函数的原型是：</p></div><div class="el-pre"><pre class="language-c" tabindex="0"><code data-line="0" class="language-c is-loaded"><span class="token keyword">void</span> <span class="token operator">*</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">seq_file</span> <span class="token operator">*</span>sfile<span class="token punctuation">,</span> <span class="token class-name">loff_t</span> <span class="token operator">*</span>pos<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code><button class="copy-code-button"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon lucide-copy"><rect x="8" y="8" width="14" height="14" rx="2" ry="2"></rect><path d="M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2"></path></svg></button></pre></div><div class="el-p"><p dir="auto"><code>sfile</code> 参数几乎总是可以忽略。<code>pos</code> 是一个整数位置，指示读取应从何处开始。位置的解释完全取决于实现；它不必是结果文件中的字节位置。由于 <code>seq_file</code> 实现通常逐步遍历一系列有趣的项目，因此位置通常被解释为指向序列中下一个项目的游标。<code>scull</code> 驱动程序将每个设备解释为序列中的一个项目，因此传入的 <code>pos</code> 只是 <code>scull_devices</code> 数组的索引。因此，<code>scull</code> 中使用的 <code>start</code> 方法是：</p></div><div class="el-pre"><pre class="language-c" tabindex="0"><code data-line="0" class="language-c is-loaded"><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token operator">*</span><span class="token function">scull_seq_start</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">seq_file</span> <span class="token operator">*</span>s<span class="token punctuation">,</span> <span class="token class-name">loff_t</span> <span class="token operator">*</span>pos<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">*</span>pos <span class="token operator">&gt;=</span> scull_nr_devs<span class="token punctuation">)</span>
        <span class="token keyword">return</span> <span class="token constant">NULL</span><span class="token punctuation">;</span> <span class="token comment">/* 没有更多内容可读 */</span>
    <span class="token keyword">return</span> scull_devices <span class="token operator">+</span> <span class="token operator">*</span>pos<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code><button class="copy-code-button"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon lucide-copy"><rect x="8" y="8" width="14" height="14" rx="2" ry="2"></rect><path d="M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2"></path></svg></button></pre></div><div class="el-p"><p dir="auto">返回值（如果非 <code>NULL</code>）是一个私有值，迭代器实现可以使用它。</p></div><div class="el-p"><p dir="auto"><code>next</code> 函数应将迭代器移动到下一个位置，如果没有剩余内容则返回 <code>NULL</code>。此方法的原型是：</p></div><div class="el-pre"><pre class="language-c" tabindex="0"><code data-line="0" class="language-c is-loaded"><span class="token keyword">void</span> <span class="token operator">*</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">seq_file</span> <span class="token operator">*</span>sfile<span class="token punctuation">,</span> <span class="token keyword">void</span> <span class="token operator">*</span>v<span class="token punctuation">,</span> <span class="token class-name">loff_t</span> <span class="token operator">*</span>pos<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code><button class="copy-code-button"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon lucide-copy"><rect x="8" y="8" width="14" height="14" rx="2" ry="2"></rect><path d="M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2"></path></svg></button></pre></div><div class="el-p"><p dir="auto">这里，<code>v</code> 是上一次调用 <code>start</code> 或 <code>next</code> 返回的迭代器，<code>pos</code> 是文件中的当前位置。<code>next</code> 应递增 <code>pos</code> 指向的值；根据你的迭代器的工作方式，你可能（尽管可能不会）希望将 <code>pos</code> 递增超过 1。以下是 <code>scull</code> 的做法：</p></div><div class="el-pre"><pre class="language-c" tabindex="0"><code data-line="0" class="language-c is-loaded"><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token operator">*</span><span class="token function">scull_seq_next</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">seq_file</span> <span class="token operator">*</span>s<span class="token punctuation">,</span> <span class="token keyword">void</span> <span class="token operator">*</span>v<span class="token punctuation">,</span> <span class="token class-name">loff_t</span> <span class="token operator">*</span>pos<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token punctuation">(</span><span class="token operator">*</span>pos<span class="token punctuation">)</span><span class="token operator">++</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">*</span>pos <span class="token operator">&gt;=</span> scull_nr_devs<span class="token punctuation">)</span>
        <span class="token keyword">return</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> scull_devices <span class="token operator">+</span> <span class="token operator">*</span>pos<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code><button class="copy-code-button"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon lucide-copy"><rect x="8" y="8" width="14" height="14" rx="2" ry="2"></rect><path d="M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2"></path></svg></button></pre></div><div class="el-p"><p dir="auto">当内核完成迭代器时，它会调用 <code>stop</code> 进行清理：</p></div><div class="el-pre"><pre class="language-c" tabindex="0"><code data-line="0" class="language-c is-loaded"><span class="token keyword">void</span> <span class="token function">stop</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">seq_file</span> <span class="token operator">*</span>sfile<span class="token punctuation">,</span> <span class="token keyword">void</span> <span class="token operator">*</span>v<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code><button class="copy-code-button"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon lucide-copy"><rect x="8" y="8" width="14" height="14" rx="2" ry="2"></rect><path d="M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2"></path></svg></button></pre></div><div class="el-p"><p dir="auto"><code>scull</code> 实现没有清理工作要做，因此其 <code>stop</code> 方法为空。</p></div><div class="el-p"><p dir="auto">值得注意的是，<code>seq_file</code> 代码在设计上不会在 <code>start</code> 和 <code>stop</code> 调用之间睡眠或执行其他非原子任务。你还保证在调用 <code>start</code> 后不久会看到一个 <code>stop</code> 调用。因此，你的 <code>start</code> 方法获取信号量或自旋锁是安全的。只要你的其他 <code>seq_file</code> 方法是原子的，整个调用序列就是原子的。（如果这段文字对你没有意义，请在阅读下一章后再回来看看。）</p></div><div class="el-p"><p dir="auto">在这些调用之间，内核调用 <code>show</code> 方法以实际向用户空间输出一些有趣的内容。此方法的原型是：</p></div><div class="el-pre"><pre class="language-c" tabindex="0"><code data-line="0" class="language-c is-loaded"><span class="token keyword">int</span> <span class="token function">show</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">seq_file</span> <span class="token operator">*</span>sfile<span class="token punctuation">,</span> <span class="token keyword">void</span> <span class="token operator">*</span>v<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code><button class="copy-code-button"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon lucide-copy"><rect x="8" y="8" width="14" height="14" rx="2" ry="2"></rect><path d="M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2"></path></svg></button></pre></div><div class="el-p"><p dir="auto">此方法应为迭代器 <code>v</code> 指示的序列中的项目创建输出。然而，它不应使用 <code>printk</code>；相反，有一组特殊的函数用于 <code>seq_file</code> 输出：</p></div><div class="el-ul"><ul>
<li data-line="0" dir="auto">
<p><code>int seq_printf(struct seq_file *sfile, const char *fmt, ...);</code><br>
这是 <code>seq_file</code> 实现的 <code>printf</code> 等效函数；它采用通常的格式字符串和额外的值参数。你还必须传递 <code>show</code> 函数给出的 <code>seq_file</code> 结构。如果 <code>seq_printf</code> 返回非零值，则表示缓冲区已满，输出被丢弃。大多数实现忽略返回值。</p>
</li>
<li data-line="3" dir="auto">
<p><code>int seq_putc(struct seq_file *sfile, char c);</code>  </p>
</li>
<li data-line="4" dir="auto">
<p><code>int seq_puts(struct seq_file *sfile, const char *s);</code><br>
这些是用户空间 <code>putc</code> 和 <code>puts</code> 函数的等效函数。</p>
</li>
<li data-line="7" dir="auto">
<p><code>int seq_escape(struct seq_file *m, const char *s, const char *esc);</code><br>
此函数等效于 <code>seq_puts</code>，但 <code>s</code> 中的任何字符如果在 <code>esc</code> 中也找到，则以八进制格式打印。<code>esc</code> 的常见值是 <code>" \t\n\"</code>，这可以防止嵌入的空白字符弄乱输出并可能混淆 shell 脚本。</p>
</li>
<li data-line="10" dir="auto">
<p><code>int seq_path(struct seq_file *sfile, struct vfsmount *m, struct dentry *dentry, char *esc);</code><br>
此函数可用于输出与给定目录条目关联的文件名。它在设备驱动程序中不太可能有用；我们在这里包含它是为了完整性。</p>
</li>
</ul></div><div class="el-p"><p dir="auto">回到我们的示例；<code>scull</code> 中使用的 <code>show</code> 方法是：</p></div><div class="el-pre"><pre class="language-c" tabindex="0"><code data-line="0" class="language-c is-loaded"><span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">scull_seq_show</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">seq_file</span> <span class="token operator">*</span>s<span class="token punctuation">,</span> <span class="token keyword">void</span> <span class="token operator">*</span>v<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">struct</span> <span class="token class-name">scull_dev</span> <span class="token operator">*</span>dev <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">scull_dev</span> <span class="token operator">*</span><span class="token punctuation">)</span> v<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">scull_qset</span> <span class="token operator">*</span>d<span class="token punctuation">;</span>
    <span class="token keyword">int</span> i<span class="token punctuation">;</span>

    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">down_interruptible</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>dev<span class="token operator">-&gt;</span>sem<span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token keyword">return</span> <span class="token operator">-</span>ERESTARTSYS<span class="token punctuation">;</span>
    <span class="token function">seq_printf</span><span class="token punctuation">(</span>s<span class="token punctuation">,</span> <span class="token string">"\nDevice %i: qset %i, q %i, sz %li\n"</span><span class="token punctuation">,</span>
        <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>dev <span class="token operator">-</span> scull_devices<span class="token punctuation">)</span><span class="token punctuation">,</span> dev<span class="token operator">-&gt;</span>qset<span class="token punctuation">,</span>
        dev<span class="token operator">-&gt;</span>quantum<span class="token punctuation">,</span> dev<span class="token operator">-&gt;</span>size<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span>d <span class="token operator">=</span> dev<span class="token operator">-&gt;</span>data<span class="token punctuation">;</span> d<span class="token punctuation">;</span> d <span class="token operator">=</span> d<span class="token operator">-&gt;</span>next<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">/* 扫描列表 */</span>
        <span class="token function">seq_printf</span><span class="token punctuation">(</span>s<span class="token punctuation">,</span> <span class="token string">" item at %p, qset at %p\n"</span><span class="token punctuation">,</span> d<span class="token punctuation">,</span> d<span class="token operator">-&gt;</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>d<span class="token operator">-&gt;</span>data <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>d<span class="token operator">-&gt;</span>next<span class="token punctuation">)</span> <span class="token comment">/* 仅转储最后一项 */</span>
            <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> dev<span class="token operator">-&gt;</span>qset<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span>d<span class="token operator">-&gt;</span>data<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>
                    <span class="token function">seq_printf</span><span class="token punctuation">(</span>s<span class="token punctuation">,</span> <span class="token string">" % 4i: %8p\n"</span><span class="token punctuation">,</span>
                        i<span class="token punctuation">,</span> d<span class="token operator">-&gt;</span>data<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token function">up</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>dev<span class="token operator">-&gt;</span>sem<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code><button class="copy-code-button"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon lucide-copy"><rect x="8" y="8" width="14" height="14" rx="2" ry="2"></rect><path d="M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2"></path></svg></button></pre></div><div class="el-p"><p dir="auto">在这里，我们终于解释了我们的“迭代器”值，它只是一个指向 <code>scull_dev</code> 结构的指针。</p></div><div class="el-p"><p dir="auto">现在 <code>scull</code> 有了完整的迭代器操作集，它必须将它们打包并连接到 <code>/proc</code> 中的一个文件。第一步是通过填充一个 <code>seq_operations</code> 结构来完成：</p></div><div class="el-pre"><pre class="language-c" tabindex="0"><code data-line="0" class="language-c is-loaded"><span class="token keyword">static</span> <span class="token keyword">struct</span> <span class="token class-name">seq_operations</span> scull_seq_ops <span class="token operator">=</span> <span class="token punctuation">{</span>
    <span class="token punctuation">.</span>start <span class="token operator">=</span> scull_seq_start<span class="token punctuation">,</span>
    <span class="token punctuation">.</span>next <span class="token operator">=</span> scull_seq_next<span class="token punctuation">,</span>
    <span class="token punctuation">.</span>stop <span class="token operator">=</span> scull_seq_stop<span class="token punctuation">,</span>
    <span class="token punctuation">.</span>show <span class="token operator">=</span> scull_seq_show
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code><button class="copy-code-button"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon lucide-copy"><rect x="8" y="8" width="14" height="14" rx="2" ry="2"></rect><path d="M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2"></path></svg></button></pre></div><div class="el-p"><p dir="auto">有了这个结构，我们必须创建一个内核理解的文件实现。我们不使用前面描述的 <code>read_proc</code> 方法；当使用 <code>seq_file</code> 时，最好以稍微低一点的级别连接到 <code>/proc</code>。这意味着创建一个 <code>file_operations</code> 结构（是的，与字符驱动程序使用的结构相同），实现内核处理文件读取和查找所需的所有操作。幸运的是，这个任务很简单。第一步是创建一个 <code>open</code> 方法，将文件连接到 <code>seq_file</code> 操作：</p></div><div class="el-pre"><pre class="language-c" tabindex="0"><code data-line="0" class="language-c is-loaded"><span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">scull_proc_open</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">inode</span> <span class="token operator">*</span>inode<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">file</span> <span class="token operator">*</span>file<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token function">seq_open</span><span class="token punctuation">(</span>file<span class="token punctuation">,</span> <span class="token operator">&amp;</span>scull_seq_ops<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code><button class="copy-code-button"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon lucide-copy"><rect x="8" y="8" width="14" height="14" rx="2" ry="2"></rect><path d="M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2"></path></svg></button></pre></div><div class="el-p"><p dir="auto"><code>seq_open</code> 的调用将文件结构与上面定义的序列操作连接起来。事实证明，<code>open</code> 是我们必须自己实现的唯一文件操作，因此我们现在可以设置我们的 <code>file_operations</code> 结构：</p></div><div class="el-pre"><pre class="language-c" tabindex="0"><code data-line="0" class="language-c is-loaded"><span class="token keyword">static</span> <span class="token keyword">struct</span> <span class="token class-name">file_operations</span> scull_proc_ops <span class="token operator">=</span> <span class="token punctuation">{</span>
    <span class="token punctuation">.</span>owner <span class="token operator">=</span> THIS_MODULE<span class="token punctuation">,</span>
    <span class="token punctuation">.</span>open <span class="token operator">=</span> scull_proc_open<span class="token punctuation">,</span>
    <span class="token punctuation">.</span>read <span class="token operator">=</span> seq_read<span class="token punctuation">,</span>
    <span class="token punctuation">.</span>llseek <span class="token operator">=</span> seq_lseek<span class="token punctuation">,</span>
    <span class="token punctuation">.</span>release <span class="token operator">=</span> seq_release
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code><button class="copy-code-button"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon lucide-copy"><rect x="8" y="8" width="14" height="14" rx="2" ry="2"></rect><path d="M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2"></path></svg></button></pre></div><div class="el-p"><p dir="auto">在这里，我们指定了我们自己的 <code>open</code> 方法，但使用现成的方法 <code>seq_read</code>、<code>seq_lseek</code> 和 <code>seq_release</code> 来处理其他所有事情。</p></div><div class="el-p"><p dir="auto">最后一步是在 <code>/proc</code> 中创建实际的文件：</p></div><div class="el-pre"><pre class="language-c" tabindex="0"><code data-line="0" class="language-c is-loaded">entry <span class="token operator">=</span> <span class="token function">create_proc_entry</span><span class="token punctuation">(</span><span class="token string">"scullseq"</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span>entry<span class="token punctuation">)</span>
    entry<span class="token operator">-&gt;</span>proc_fops <span class="token operator">=</span> <span class="token operator">&amp;</span>scull_proc_ops<span class="token punctuation">;</span>
</code><button class="copy-code-button"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon lucide-copy"><rect x="8" y="8" width="14" height="14" rx="2" ry="2"></rect><path d="M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2"></path></svg></button></pre></div><div class="el-p"><p dir="auto">我们没有使用 <code>create_proc_read_entry</code>，而是调用了更低级别的 <code>create_proc_entry</code>，其原型如下：</p></div><div class="el-pre"><pre class="language-c" tabindex="0"><code data-line="0" class="language-c is-loaded"><span class="token keyword">struct</span> <span class="token class-name">proc_dir_entry</span> <span class="token operator">*</span><span class="token function">create_proc_entry</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>name<span class="token punctuation">,</span>
    <span class="token class-name">mode_t</span> mode<span class="token punctuation">,</span>
    <span class="token keyword">struct</span> <span class="token class-name">proc_dir_entry</span> <span class="token operator">*</span>parent<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code><button class="copy-code-button"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon lucide-copy"><rect x="8" y="8" width="14" height="14" rx="2" ry="2"></rect><path d="M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2"></path></svg></button></pre></div><div class="el-p"><p dir="auto">参数与 <code>create_proc_read_entry</code> 中的等效参数相同：文件的名称、其保护模式和父目录。</p></div><div class="el-p"><p dir="auto">通过上述代码，<code>scull</code> 有了一个新的 <code>/proc</code> 条目，看起来与之前的条目非常相似。然而，它更优越，因为无论输出变得多大，它都能正常工作，正确处理查找，并且通常更容易阅读和维护。我们建议使用 <code>seq_file</code> 来实现包含多行输出的文件。</p></div></div></div></div></div><div class="el-h2 heading-wrapper"><h2 data-heading="`ioctl` 方法" dir="auto" class="heading" id="`ioctl`_方法"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><code>ioctl</code> 方法</h2><div class="heading-children"><div class="el-p"><p dir="auto"><code>ioctl</code> 是一个系统调用，它作用于文件描述符；它接收一个标识要执行的命令的数字和（可选的）另一个参数，通常是一个指针。作为使用 <code>/proc</code> 文件系统的替代方法，你可以实现一些专门用于调试的 <code>ioctl</code> 命令。这些命令可以将相关的数据结构从驱动程序复制到用户空间，你可以在那里检查它们。</p></div><div class="el-p"><p dir="auto">使用 <code>ioctl</code> 获取信息比使用 <code>/proc</code> 稍微困难一些，因为你需要另一个程序来发出 <code>ioctl</code> 并显示结果。这个程序必须编写、编译并与你正在测试的模块保持同步。另一方面，驱动程序端的代码可能比实现 <code>/proc</code> 文件所需的代码更容易。</p></div><div class="el-p"><p dir="auto">有时 <code>ioctl</code> 是获取信息的最佳方式，因为它比读取 <code>/proc</code> 更快。如果必须在数据写入屏幕之前对其执行一些工作，以二进制形式检索数据比读取文本文件更有效。此外，<code>ioctl</code> 不需要将数据分割成小于一页的片段。</p></div><div class="el-p"><p dir="auto"><code>ioctl</code> 方法的另一个有趣的优势是，即使调试被禁用，信息检索命令也可以留在驱动程序中。与 <code>/proc</code> 文件不同，<code>/proc</code> 文件对任何查看目录的人都是可见的（太多人可能会好奇“那个奇怪的文件是什么”），未记录的 <code>ioctl</code> 命令可能会被忽视。此外，如果驱动程序发生奇怪的事情，它们仍然存在。唯一的缺点是模块会稍微变大。</p></div><div class="mod-footer mod-ui"></div></div></div></div></div></div><div class="sidebar-right sidebar"><div class="sidebar-handle"></div><div class="sidebar-topbar"><div class="topbar-content"></div><div class="clickable-icon sidebar-collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="100%" height="100%" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="3" stroke-linecap="round" stroke-linejoin="round" class="svg-icon"><path d="M21 3H3C1.89543 3 1 3.89543 1 5V19C1 20.1046 1.89543 21 3 21H21C22.1046 21 23 20.1046 23 19V5C23 3.89543 22.1046 3 21 3Z"></path><path d="M10 4V20"></path><path d="M4 7H7"></path><path d="M4 10H7"></path><path d="M4 13H7"></path></svg></div></div><div class="sidebar-content"><div class="graph-view-wrapper"><div class="sidebar-section-header">Interactive Graph</div><div class="graph-view-placeholder">
		<div class="graph-view-container">
			<div class="graph-icon graph-expand" role="button" aria-label="Expand" data-tooltip-position="top"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon"><line x1="7" y1="17" x2="17" y2="7"></line><polyline points="7 7 17 7 17 17"></polyline></svg></div>
			<canvas id="graph-canvas" class="hide" width="512px" height="512px"></canvas>
		</div>
		</div></div><div class="tree-container mod-root nav-folder tree-item outline-tree" data-depth="0"><div class="tree-header"><span class="sidebar-section-header">Table Of Contents</span><button class="clickable-icon collapse-tree-button" aria-label="Collapse All"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"></svg></button></div><div class="tree-scroll-area tree-item-children nav-folder-children"><div class="tree-item mod-tree-folder nav-folder mod-collapsible is-collapsed" style="display: none;"></div><div class="tree-item" data-depth="1"><a class="tree-link" href="第4章-调试技术/4.3-通过查询调试.html#4.3 通过查询调试"><div class="tree-item-contents heading-link" heading-name="4.3 通过查询调试"><span class="tree-item-title">4.3 通过查询调试</span></div></a><div class="tree-item-children nav-folder-children"><div class="tree-item mod-collapsible" data-depth="2"><a class="tree-link" href="第4章-调试技术/4.3-通过查询调试.html#使用_`/proc`_文件系统"><div class="tree-item-contents heading-link" heading-name="使用 `/proc` 文件系统"><div class="collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><span class="tree-item-title">使用 <code>/proc</code> 文件系统</span></div></a><div class="tree-item-children nav-folder-children"><div class="tree-item" data-depth="3"><a class="tree-link" href="第4章-调试技术/4.3-通过查询调试.html#在_`/proc`_中实现文件"><div class="tree-item-contents heading-link" heading-name="在 `/proc` 中实现文件"><span class="tree-item-title">在 <code>/proc</code> 中实现文件</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="3"><a class="tree-link" href="第4章-调试技术/4.3-通过查询调试.html#旧接口"><div class="tree-item-contents heading-link" heading-name="旧接口"><span class="tree-item-title">旧接口</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="3"><a class="tree-link" href="第4章-调试技术/4.3-通过查询调试.html#创建你的_`/proc`_文件"><div class="tree-item-contents heading-link" heading-name="创建你的 `/proc` 文件"><span class="tree-item-title">创建你的 <code>/proc</code> 文件</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="3"><a class="tree-link" href="第4章-调试技术/4.3-通过查询调试.html#`seq_file`_接口"><div class="tree-item-contents heading-link" heading-name="`seq_file` 接口"><span class="tree-item-title"><code>seq_file</code> 接口</span></div></a><div class="tree-item-children nav-folder-children"></div></div></div></div><div class="tree-item" data-depth="2"><a class="tree-link" href="第4章-调试技术/4.3-通过查询调试.html#`ioctl`_方法"><div class="tree-item-contents heading-link" heading-name="`ioctl` 方法"><span class="tree-item-title"><code>ioctl</code> 方法</span></div></a><div class="tree-item-children nav-folder-children"></div></div></div></div></div></div></div><script defer="">let rs = document.querySelector(".sidebar-right"); rs.classList.add("is-collapsed"); if (window.innerWidth > 768) rs.classList.remove("is-collapsed"); rs.style.setProperty("--sidebar-width", localStorage.getItem("sidebar-right-width"));</script></div></div></body></html>
# 本书概述

从现在开始，我们将进入内核编程的世界。第2章介绍了模块化，解释了模块化的奥秘，并展示了运行模块的代码。第3章讨论了字符驱动程序，并展示了一个基于内存的设备驱动程序的完整代码，该驱动程序可以用于读写操作。使用内存作为设备的硬件基础，使得任何人都可以在不需要特殊硬件的情况下运行示例代码。

调试技术是程序员的重要工具，第4章将介绍这些技术。对于想要在现代内核上进行开发的程序员来说，管理并发和竞争条件同样重要。第5章涉及并发访问资源所带来的问题，并介绍了Linux控制并发的机制。

在掌握了调试和并发管理技能之后，我们将转向字符驱动程序的高级功能，如阻塞操作、select的使用以及重要的ioctl调用；这些主题是第6章的主要内容。

在处理硬件管理之前，我们将剖析内核的更多软件接口：第7章展示了内核中时间的管理方式，第8章解释了内存分配。

接下来我们将专注于硬件。第9章描述了设备上的I/O端口和内存缓冲区的管理；之后是第10章的中断处理。不幸的是，并非所有人都能运行这些章节的示例代码，因为测试软件接口中断确实需要一些硬件支持。我们尽力将所需的硬件支持降到最低，但你仍然需要一些简单的硬件，如标准的并行端口，才能运行这些章节的示例代码。

第11章涵盖了内核中数据类型的使用以及编写可移植代码的技巧。

本书的后半部分专注于更高级的主题。我们首先深入硬件，特别是特定外围总线的工作原理。第12章详细介绍了如何为PCI设备编写驱动程序，第13章则探讨了与USB设备交互的API。

在理解了外围总线之后，我们可以详细研究Linux设备模型，这是内核用于描述其管理的硬件和软件资源的抽象层。第14章从下至上介绍了设备模型的基础设施，从kobject类型开始，逐步向上。它涵盖了设备模型与真实硬件的集成；然后利用这些知识讨论了热插拔设备和电源管理等主题。

第15章，我们将深入探讨Linux内存管理。本章展示了如何将内核内存映射到用户空间（mmap系统调用），将用户内存映射到内核空间（使用get_user_pages），以及如何将这两种内存映射到设备空间（以执行直接内存访问[DMA]操作）。

我们对内存的理解将有助于接下来的两章，这两章涵盖了其他主要的驱动程序类别。第16章介绍了块驱动程序，并展示了它们与我们迄今为止使用的字符驱动程序的不同之处。然后第17章深入探讨了网络驱动程序的编写。最后，我们讨论了串行驱动程序（第18章）并提供了参考文献。

# Hello World 模块

许多编程书籍都以“hello world”示例作为展示最简单程序的方式。本书讨论的是内核模块而非程序；因此，为了满足心急的读者，以下代码是一个完整的“hello world”模块：

```c
#include <linux/init.h>
#include <linux/module.h>
MODULE_LICENSE("Dual BSD/GPL");

static int hello_init(void)
{
    printk(KERN_ALERT "Hello, world\n");
    return 0;
}

static void hello_exit(void)
{
    printk(KERN_ALERT "Goodbye, cruel world\n");
}

module_init(hello_init);
module_exit(hello_exit);
```

该模块定义了两个函数，一个在模块加载到内核时调用（`hello_init`），另一个在模块移除时调用（`hello_exit`）。`module_init` 和 `module_exit` 行使用特殊的内核宏来指示这两个函数的作用。另一个特殊宏（`MODULE_LICENSE`）用于告诉内核该模块采用自由许可证；如果没有这样的声明，内核在加载模块时会发出警告。

`printk` 函数在 Linux 内核中定义，并可供模块使用；它的行为类似于标准 C 库函数 `printf`。内核需要自己的打印函数，因为它独立运行，不依赖于 C 库的帮助。模块可以调用 `printk`，因为在 `insmod` 加载模块后，模块会链接到内核，并可以访问内核的公共符号（函数和变量，详见下一节）。字符串 `KERN_ALERT` 是消息的优先级。我们在该模块中指定了高优先级，因为默认优先级的消息可能不会显示在任何有用的地方，具体取决于你运行的内核版本、`klogd` 守护进程的版本以及你的配置。你现在可以忽略这个问题；我们将在第4章中详细解释。

你可以使用 `insmod` 和 `rmmod` 工具测试该模块，如下所示。注意，只有超级用户才能加载和卸载模块。

```bash
% make
make[1]: Entering directory `/usr/src/linux-2.6.10'
CC [M] /home/ldd3/src/misc-modules/hello.o
Building modules, stage 2.
MODPOST
CC /home/ldd3/src/misc-modules/hello.mod.o
LD [M] /home/ldd3/src/misc-modules/hello.ko
make[1]: Leaving directory `/usr/src/linux-2.6.10'
% su
root# insmod ./hello.ko
Hello, world
root# rmmod hello
Goodbye cruel world
root#
```

请注意，为了使上述命令序列正常工作，你必须有一个正确配置并构建的内核树，并且 `makefile` 能够找到它（例如 `/usr/src/linux-2.6.10`）。我们将在“编译和加载”部分详细介绍模块的构建过程。

根据系统传递消息行的机制，你的输出可能会有所不同。特别是，之前的屏幕截图来自文本控制台；如果你在窗口系统下的终端模拟器中运行 `insmod` 和 `rmmod`，你将不会在屏幕上看到任何内容。消息会发送到系统日志文件之一，例如 `/var/log/messages`（实际文件名因 Linux 发行版而异）。内核消息传递机制将在第4章中描述。

如你所见，编写模块并不像你想象的那么困难——至少，只要模块不需要做任何有意义的事情。困难的部分在于理解你的设备以及如何最大化性能。我们将在本章深入探讨模块化，并将设备特定的问题留到后面的章节。

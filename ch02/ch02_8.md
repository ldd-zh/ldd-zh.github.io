# 模块参数

驱动程序需要知道的几个参数可能因系统而异。这些参数可以从使用的设备号（我们将在下一章看到）到驱动程序应如何操作的许多方面。例如，SCSI 适配器的驱动程序通常具有控制标记命令队列使用的选项，而 IDE 驱动程序允许用户控制 DMA 操作。如果你的驱动程序控制较旧的硬件，它可能还需要明确告知在哪里找到该硬件的 I/O 端口或 I/O 内存地址。内核通过使驱动程序能够指定在加载驱动程序的模块时可以更改的参数来支持这些需求。

这些参数值可以在加载时由 `insmod` 或 `modprobe` 分配；后者还可以从其配置文件（`/etc/modprobe.conf`）中读取参数分配。这些命令接受在命令行上指定几种类型的值。为了演示此功能，想象一下对本章开头的“hello world”模块（称为 `hellop`）进行了一个非常需要的增强。我们添加了两个参数：一个名为 `howmany` 的整数值和一个名为 `whom` 的字符串。我们的功能更强大的模块在加载时不仅向 `whom` 问候一次，而是 `howmany` 次。这样的模块可以通过以下命令行加载：

```bash
insmod hellop howmany=10 whom="Mom"
```

以这种方式加载后，`hellop` 会说“Hello, Mom” 10 次。

然而，在 `insmod` 可以更改模块参数之前，模块必须使它们可用。参数使用 `module_param` 宏声明，该宏在 `moduleparam.h` 中定义。`module_param` 接受三个参数：变量的名称、其类型和用于伴随的 `sysfs` 条目的权限掩码。该宏应放在任何函数之外，通常位于源文件的顶部。因此，`hellop` 将声明其参数并使它们对 `insmod` 可用，如下所示：

```c
static char *whom = "world";
static int howmany = 1;
module_param(howmany, int, S_IRUGO);
module_param(whom, charp, S_IRUGO);
```

支持多种类型的模块参数：

- `bool` 和 `invbool`：布尔值（真或假），相关变量应为 `int` 类型。`invbool` 类型反转值，使真值变为假，反之亦然。
- `charp`：字符指针值。为用户提供的字符串分配内存，并相应地设置指针。
- `int`、`long`、`short`、`uint`、`ulong`、`ushort`：各种长度的基本整数值。以 `u` 开头的版本用于无符号值。

模块加载器还支持数组参数，其中值以逗号分隔的列表形式提供。要声明数组参数，请使用：

```c
module_param_array(name, type, num, perm);
```

其中 `name` 是数组（和参数）的名称，`type` 是数组元素的类型，`num` 是一个整数变量，`perm` 是通常的权限值。如果在加载时设置了数组参数，`num` 将设置为提供的值的数量。模块加载器拒绝接受超过数组容量的值。

如果你确实需要一个不在上述列表中的类型，模块代码中有钩子允许你定义它们；有关如何执行此操作的详细信息，请参阅 `moduleparam.h`。所有模块参数都应提供默认值；`insmod` 仅在用户明确告知时更改值。模块可以通过将参数与其默认值进行比较来检查显式参数。

`module_param` 的最后一个字段是权限值；你应该使用 `<linux/stat.h>` 中找到的定义。此值控制谁可以访问 `sysfs` 中模块参数的表示。如果 `perm` 设置为 0，则根本没有 `sysfs` 条目；否则，它出现在 `/sys/module` 下，并具有给定的权限集。使用 `S_IRUGO` 表示可以被所有人读取但不能更改的参数；`S_IRUGO|S_IWUSR` 允许 root 更改参数。请注意，如果 `sysfs` 更改了参数，模块看到的该参数的值会更改，但模块不会以任何其他方式收到通知。除非你准备检测更改并做出相应反应，否则你可能不应使模块参数可写。

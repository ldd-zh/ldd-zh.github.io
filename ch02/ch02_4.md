# 编译和加载

本章开头的“hello world”示例简要演示了如何构建模块并将其加载到系统中。当然，整个过程比我们目前看到的要复杂得多。本节将详细介绍模块作者如何将源代码转换为内核中执行的子系统。

## 编译模块

首先，我们需要了解模块的构建过程。模块的构建过程与用户空间应用程序的构建过程有很大不同；内核是一个大型的独立程序，对其各个部分的组合方式有详细而明确的要求。构建过程也与以前的内核版本不同；新的构建系统更易于使用，并且产生更正确的结果，但它看起来与以前大不相同。内核构建系统是一个复杂的野兽，我们只看了其中的一小部分。内核源代码中的 `Documentation/kbuild` 目录中的文件是任何想要了解表面下真正发生的事情的人的必读材料。

在构建内核模块之前，你需要满足一些先决条件。首先是确保你有足够新版本的编译器、模块工具和其他必要工具。内核文档目录中的 `Documentation/Changes` 文件始终列出了所需的工具版本；在继续之前，你应该查阅它。尝试使用错误的工具版本构建内核（及其模块）可能会导致无数微妙且难以解决的问题。请注意，有时编译器版本过新可能与过旧一样有问题；内核源代码对编译器做了很多假设，新版本有时会暂时破坏一些东西。

如果你还没有一个内核树，或者还没有配置和构建该内核，现在是时候去做了。如果没有这个树，你无法为2.6内核构建可加载模块。实际运行你正在构建的内核也很有帮助（尽管不是必需的）。

一旦你设置好一切，为你的模块创建一个 `makefile` 就很简单了。事实上，对于本章前面展示的“hello world”示例，只需一行即可：

```makefile
obj-m := hello.o
```

熟悉 `make` 但不熟悉2.6内核构建系统的读者可能会想知道这个 `makefile` 是如何工作的。毕竟，上面的行看起来不像传统的 `makefile`。答案当然是内核构建系统处理了其余部分。上面的赋值（利用了 GNU `make` 提供的扩展语法）声明有一个模块将从目标文件 `hello.o` 构建。生成的模块在从目标文件构建后命名为 `hello.ko`。

如果你有一个名为 `module.ko` 的模块，它由两个源文件生成（例如 `file1.c` 和 `file2.c`），正确的写法是：

```makefile
obj-m := module.o
module-objs := file1.o file2.o
```

为了使上述 `makefile` 正常工作，它必须在更大的内核构建系统的上下文中调用。如果你的内核源代码树位于 `~/kernel-2.6` 目录中，构建模块所需的 `make` 命令（在包含模块源代码和 `makefile` 的目录中键入）将是：

```bash
make -C ~/kernel-2.6 M=`pwd` modules
```

该命令首先使用 `-C` 选项将其目录更改为提供的目录（即你的内核源代码目录）。在那里，它找到内核的顶级 `makefile`。`M=` 选项使该 `makefile` 在尝试构建 `modules` 目标之前移回你的模块源代码目录。该目标又引用 `obj-m` 变量中找到的模块列表，我们在示例中将其设置为 `module.o`。

键入上述 `make` 命令可能会在一段时间后变得繁琐，因此内核开发人员开发了一种 `makefile` 惯用语，使那些在内核树之外构建模块的人生活更轻松。诀窍是将你的 `makefile` 编写如下：

```makefile
# 如果定义了 KERNELRELEASE，我们从内核构建系统调用，可以使用它的语言。
ifneq ($(KERNELRELEASE),)
obj-m := hello.o

# 否则我们从命令行直接调用；调用内核构建系统。
else

KERNELDIR ?= /lib/modules/$(shell uname -r)/build
PWD := $(shell pwd)

default:
    $(MAKE) -C $(KERNELDIR) M=$(PWD) modules

endif
```

我们再次看到扩展的 GNU `make` 语法在起作用。这个 `makefile` 在典型的构建中被读取两次。当从命令行调用 `makefile` 时，它会注意到 `KERNELRELEASE` 变量尚未设置。它通过利用已安装模块目录中的符号链接 `build` 指向内核构建树的事实来定位内核源代码目录。如果你没有实际运行你正在构建的内核，你可以在命令行上提供 `KERNELDIR=` 选项，设置 `KERNELDIR` 环境变量，或者重写 `makefile` 中设置 `KERNELDIR` 的行。一旦找到内核源代码树，`makefile` 就会调用 `default:` 目标，该目标运行第二个 `make` 命令（在 `makefile` 中参数化为 `$(MAKE)`）以调用内核构建系统，如前所述。在第二次读取时，`makefile` 设置 `obj-m`，内核 `makefile` 负责实际构建模块。

这种构建模块的机制可能会让你觉得有点笨拙和晦涩。然而，一旦你习惯了它，你可能会欣赏内核构建系统中编程的功能。请注意，上面的内容并不是一个完整的 `makefile`；一个真正的 `makefile` 通常还包括清理不需要的文件、安装模块等目标。你可以参考示例源代码目录中的 `makefile` 来查看完整的示例。

## 加载和卸载模块

模块构建完成后，下一步就是将其加载到内核中。正如我们已经提到的，`insmod` 可以帮你完成这个任务。该程序将模块代码和数据加载到内核中，内核随后执行类似于 `ld` 的功能，将模块中未解析的符号链接到内核的符号表。不过，与链接器不同的是，内核不会修改模块的磁盘文件，而是修改内存中的副本。`insmod` 接受许多命令行选项（详见手册页），并且它可以在将模块链接到当前内核之前为模块中的参数赋值。因此，如果模块设计正确，它可以在加载时进行配置；加载时配置比编译时配置更灵活，尽管后者有时仍在使用。加载时配置将在本章后面的“模块参数”部分进行解释。

感兴趣的读者可能想看看内核如何支持 `insmod`：它依赖于 `kernel/module.c` 中定义的系统调用。函数 `sys_init_module` 分配内核内存来保存模块（该内存使用 `vmalloc` 分配；详见第8章中的“vmalloc 及其朋友”部分）；然后将模块文本复制到该内存区域，通过内核符号表解析模块中的内核引用，并调用模块的初始化函数以启动一切。

如果你查看内核源代码，你会发现系统调用的名称都以 `sys_` 为前缀。所有系统调用都是如此，其他函数则没有；在源代码中搜索系统调用时，记住这一点很有用。

`modprobe` 工具值得一提。`modprobe` 与 `insmod` 类似，都是将模块加载到内核中。不同之处在于，`modprobe` 会查看要加载的模块，检查它是否引用了内核中当前未定义的任何符号。如果发现任何此类引用，`modprobe` 会在当前模块搜索路径中查找定义相关符号的其他模块。当 `modprobe` 找到这些模块（这些模块是正在加载的模块所需的）时，它也会将它们加载到内核中。如果你在这种情况下使用 `insmod`，命令将失败，并在系统日志文件中留下“未解析符号”的消息。

如前所述，可以使用 `rmmod` 工具从内核中移除模块。请注意，如果内核认为模块仍在使用中（例如，某个程序仍在使用模块导出的设备打开文件），或者内核配置为不允许模块移除，则模块移除将失败。可以将内核配置为允许“强制”移除模块，即使它们看起来正在使用中。然而，如果你考虑使用此选项，情况可能已经非常糟糕，重启系统可能是更好的选择。

`lsmod` 程序会生成当前加载到内核中的模块列表。它还提供了一些其他信息，例如哪些其他模块正在使用特定模块。`lsmod` 通过读取 `/proc/modules` 虚拟文件来工作。当前加载的模块的信息也可以在 `sysfs` 虚拟文件系统中的 `/sys/module` 下找到。

## 版本依赖

请记住，你的模块代码必须为每个链接的内核版本重新编译——至少在不存在 `modversions` 的情况下是这样，这里不讨论 `modversions`，因为它们更多是为发行版制作者准备的。模块与特定内核版本中定义的数据结构和函数原型紧密相关；模块所见的接口可能在不同内核版本之间发生显著变化。当然，这在开发内核中尤为明显。

内核不会假设给定的模块是针对正确内核版本构建的。构建过程中的一个步骤是将你的模块链接到当前内核树中的一个文件（称为 `vermagic.o`）；该对象包含有关模块构建的内核的大量信息，包括目标内核版本、编译器版本以及许多重要配置变量的设置。当尝试加载模块时，可以测试这些信息是否与运行中的内核兼容。如果不匹配，模块将不会被加载；相反，你会看到类似以下的内容：

```bash
# insmod hello.ko
Error inserting './hello.ko': -1 Invalid module format
```

查看系统日志文件（`/var/log/messages` 或你的系统配置使用的任何文件）将揭示导致模块加载失败的具体问题。

如果你需要为特定内核版本编译模块，你需要使用该特定版本的构建系统和源代码树。只需修改前面示例 `makefile` 中的 `KERNELDIR` 变量即可。

内核接口经常在版本之间发生变化。如果你正在编写一个旨在与多个内核版本兼容的模块（特别是如果它必须跨主要版本工作），你可能需要使用宏和 `#ifdef` 结构来使你的代码正确构建。本书的这一版只涉及一个主要版本的内核，因此你在我们的示例代码中不会经常看到版本测试。但有时确实需要它们。在这种情况下，你可以使用 `<linux/version.h>` 中的定义。该头文件由 `<linux/module.h>` 自动包含，定义了以下宏：

- `UTS_RELEASE`：该宏扩展为描述此内核树版本的字符串。例如，`"2.6.10"`。
- `LINUX_VERSION_CODE`：该宏扩展为内核版本的二进制表示，每个版本号部分占一个字节。例如，2.6.10 的代码是 132618（即 0x02060a）。有了这些信息，你可以（几乎）轻松确定你正在处理的内核版本。
- `KERNEL_VERSION(major,minor,release)`：该宏用于从构成版本号的各个数字构建整数版本代码。例如，`KERNEL_VERSION(2,6,10)` 扩展为 132618。当你需要比较当前版本和已知检查点时，该宏非常有用。

大多数基于内核版本的依赖可以通过使用 `KERNEL_VERSION` 和 `LINUX_VERSION_CODE` 的预处理器条件来解决。然而，版本依赖不应使驱动程序代码充满复杂的 `#ifdef` 条件；处理不兼容性的最佳方法是将它们限制在特定的头文件中。通常，显式依赖于版本（或平台）的代码应隐藏在低级宏或函数后面。高级代码可以调用这些函数，而无需关心低级细节。以这种方式编写的代码往往更易于阅读且更健壮。

## 平台依赖

每个计算机平台都有其独特之处，内核设计者可以自由利用所有这些独特之处来实现目标对象文件的最佳性能。

与应用程序开发者不同，他们必须将代码与预编译的库链接并遵守参数传递约定，内核开发者可以将某些处理器寄存器专用于特定角色，并且他们已经这样做了。此外，内核代码可以针对 CPU 系列中的特定处理器进行优化，以从目标平台中获得最佳性能：与通常以二进制格式分发的应用程序不同，内核的自定义编译可以针对特定的计算机集进行优化。

例如，IA32（x86）架构已被细分为几种不同的处理器类型。旧的 80386 处理器仍然受支持（目前），尽管其指令集按现代标准来看相当有限。该架构中更现代的处理器引入了许多新功能，包括进入内核的更快指令、处理器间锁定、数据复制等。较新的处理器在正确模式下运行时还可以使用 36 位（或更大）的物理地址，使它们能够寻址超过 4 GB 的物理内存。其他处理器系列也看到了类似的改进。根据各种配置选项，内核可以构建为利用这些附加功能。

显然，如果模块要与给定的内核一起工作，它必须与内核一样理解目标处理器。再次，`vermagic.o` 对象文件发挥作用。当加载模块时，内核会检查模块的处理器特定配置选项，并确保它们与运行中的内核匹配。如果模块是用不同的选项编译的，它将不会被加载。

如果你计划编写一个用于广泛分发的驱动程序，你可能想知道如何支持所有这些不同的变体。当然，最好的答案是以 GPL 兼容的许可证发布你的驱动程序，并将其贡献给主线内核。如果做不到这一点，以源代码形式分发你的驱动程序以及一组在用户系统上编译它的脚本可能是最佳答案。一些供应商已经发布了使此任务更轻松的工具。如果你必须以二进制形式分发驱动程序，你需要查看目标发行版提供的不同内核，并为每个内核提供一个模块版本。请务必考虑自发行版发布以来可能发布的任何勘误内核。然后，还需要考虑许可问题，正如我们在第1章的“许可条款”部分讨论的那样。通常，以源代码形式分发是更简单的方式。

# 内核符号表

我们已经看到 `insmod` 如何根据公共内核符号表解析未定义的符号。该表包含全局内核项（函数和变量）的地址，这些项是实现模块化驱动程序所需的。当加载模块时，模块导出的任何符号都会成为内核符号表的一部分。在通常情况下，模块实现自己的功能而不需要导出任何符号。然而，当其他模块可能受益于使用它们时，你需要导出符号。

新模块可以使用你的模块导出的符号，你可以在其他模块之上堆叠新模块。模块堆叠在主流通用内核源代码中也有实现：`msdos` 文件系统依赖于 `fat` 模块导出的符号，每个输入 USB 设备模块堆叠在 `usbcore` 和 `input` 模块之上。

模块堆叠在复杂项目中非常有用。如果新的抽象以设备驱动程序的形式实现，它可能会为硬件特定的实现提供一个插槽。例如，`video-for-linux` 驱动程序集分为一个通用模块，该模块导出由特定硬件的低级设备驱动程序使用的符号。根据你的设置，你加载通用视频模块和已安装硬件的特定模块。并行端口和各种可连接设备的支持也以相同的方式处理，USB 内核子系统也是如此。图2-2显示了并行端口子系统中的堆叠；箭头显示了模块之间以及与内核编程接口之间的通信。

当使用堆叠模块时，了解 `modprobe` 实用程序会很有帮助。如前所述，`modprobe` 的功能与 `insmod` 类似，但它还会加载你想要的模块所需的任何其他模块。因此，一个 `modprobe` 命令有时可以替代多次 `insmod` 调用（尽管当你从当前目录加载自己的模块时，你仍然需要 `insmod`，因为 `modprobe` 只查看标准安装的模块目录）。

通过将模块拆分为多个层来使用堆叠可以帮助减少开发时间，因为每一层都得到了简化。这类似于我们在第1章中讨论的机制与策略的分离。

Linux 内核头文件提供了一种方便的方式来管理符号的可见性，从而减少命名空间污染（用可能与其他地方定义的名称冲突的名称填充命名空间）并促进正确的信息隐藏。如果你的模块需要导出符号供其他模块使用，应使用以下宏：

```c
EXPORT_SYMBOL(name);
EXPORT_SYMBOL_GPL(name);
```

上述任一宏使给定符号在模块外部可用。GPL 版本仅使符号对 GPL 许可的模块可用。符号必须在模块文件的全局部分中导出，在任何函数之外，因为这些宏扩展为特殊用途变量的声明，该变量预期在全局范围内可访问。该变量存储在模块可执行文件的一个特殊部分（“ELF 部分”）中，内核在加载时使用该部分来查找模块导出的变量。（感兴趣的读者可以查看 `<linux/module.h>` 以了解详细信息，尽管这些细节不需要使事情正常工作。）

# 内核模块与应用程序的区别

在我们继续之前，值得强调内核模块与应用程序之间的各种区别。

虽然大多数中小型应用程序从头到尾执行单一任务，但每个内核模块只是注册自己以服务于未来的请求，并且其初始化函数会立即终止。换句话说，模块的初始化函数的任务是为以后调用模块的函数做准备；就像模块在说：“我在这里，这是我能做的。”模块的退出函数（示例中的 `hello_exit`）在模块卸载之前调用。它应该告诉内核：“我不在了；不要再让我做任何事情。”这种编程方法类似于事件驱动编程，但并非所有应用程序都是事件驱动的，而每个内核模块都是。事件驱动应用程序与内核代码之间的另一个主要区别在于退出函数：应用程序在终止时可以懒惰地释放资源或完全避免清理，而模块的退出函数必须仔细撤销初始化函数所构建的一切，否则这些部分将一直保留到系统重新启动。

顺便说一句，能够卸载模块是模块化最受赞赏的特性之一，因为它有助于缩短开发时间；你可以在不经过冗长的关机/重启周期的情况下测试新驱动程序的连续版本。

作为程序员，你知道应用程序可以调用它未定义的函数：链接阶段使用适当的函数库解析外部引用。`printf` 就是其中之一，它在 `libc` 中定义。另一方面，模块仅链接到内核，它只能调用内核导出的函数；没有库可以链接。例如，之前在 `hello.c` 中使用的 `printk` 函数是内核中定义的 `printf` 版本，并导出给模块使用。它的行为与原始函数类似，但有一些小差异，主要区别在于不支持浮点数。

图2-1展示了模块中如何使用函数调用和函数指针将新功能添加到运行中的内核。

## 用户空间与内核空间

模块在内核空间中运行，而应用程序在用户空间中运行。这个概念是操作系统理论的基础。

操作系统的角色实际上是为程序提供计算机硬件的一致视图。此外，操作系统必须考虑程序的独立操作和防止对资源的未授权访问。只有在 CPU 强制执行系统软件与应用程序之间的保护时，这一非平凡任务才可能实现。

每个现代处理器都能够强制执行这种行为。选择的方法是在 CPU 本身中实现不同的操作模式（或级别）。这些级别具有不同的角色，某些操作在较低级别是不允许的；程序代码只能通过有限数量的门从一个级别切换到另一个级别。Unix 系统设计为利用这一硬件特性，使用两个这样的级别。所有当前处理器至少有两个保护级别，有些（如 x86 系列）有更多级别；当存在多个级别时，使用最高和最低级别。在 Unix 下，内核在最高级别（也称为**管理模式**）执行，其中允许所有操作，而应用程序在最低级别（所谓的**用户模式**）执行，处理器在其中调节对硬件的直接访问和对内存的未授权访问。

我们通常将执行模式称为**内核空间**和**用户空间**。这些术语不仅包括两种模式中固有的不同权限级别，还包括每种模式可以有自己的内存映射——自己的地址空间——的事实。

每当应用程序发出系统调用或被硬件中断挂起时，Unix 都会将执行从用户空间转移到内核空间。执行系统调用的内核代码在进程的上下文中工作——它代表调用进程操作，并能够访问进程地址空间中的数据。另一方面，处理中断的代码与进程是异步的，并且与任何特定进程无关。

模块的作用是扩展内核功能；模块化代码在内核空间中运行。通常，驱动程序执行前面概述的两种任务：模块中的一些函数作为系统调用的一部分执行，而另一些则负责中断处理。

## 内核中的并发性

内核编程与传统应用程序编程的一个显著区别是并发性问题。大多数应用程序（除了多线程应用程序）通常按顺序运行，从头到尾，无需担心环境中可能发生的其他事情。内核代码并不运行在如此简单的世界中，即使是最简单的内核模块也必须考虑到许多事情可能同时发生。

内核编程中有几个并发源。自然，Linux 系统运行多个进程，其中多个进程可能同时尝试使用你的驱动程序。大多数设备能够中断处理器；中断处理程序异步运行，并且可以在你的驱动程序尝试执行其他操作时被调用。一些软件抽象（如内核定时器，将在第7章介绍）也是异步运行的。此外，Linux 可以在对称多处理器（SMP）系统上运行，结果可能是你的驱动程序在多个 CPU 上并发执行。最后，在2.6内核中，内核代码已被设置为可抢占的；这一变化导致即使是单处理器系统也具有与多处理器系统相同的并发问题。

因此，Linux 内核代码（包括驱动程序代码）必须是可重入的——它必须能够在多个上下文中同时运行。数据结构必须精心设计，以保持多个执行线程的分离，代码必须小心访问共享数据，以防止数据损坏。编写处理并发并避免竞争条件（执行顺序不当导致不良行为的情况）的代码需要深思熟虑，并且可能很棘手。正确管理并发是编写正确内核代码的必要条件；因此，本书中的每个示例驱动程序都是在考虑并发性的情况下编写的。我们将在遇到这些技术时进行解释；第5章也专门讨论了这个问题以及可用于并发管理的内核原语。

驱动程序程序员常犯的一个错误是假设只要特定代码段不进入睡眠（或“阻塞”），并发就不是问题。即使在以前的内核（不可抢占）中，这种假设在多处理器系统上也是无效的。在2.6内核中，内核代码几乎不能假设它可以在给定的代码段中保持处理器。如果你不编写考虑并发性的代码，它将面临灾难性的失败，这些失败可能非常难以调试。

## 当前进程

尽管内核模块不像应用程序那样按顺序执行，但内核执行的大多数操作都是代表特定进程完成的。内核代码可以通过访问 `<asm/current.h>` 中定义的全局项 `current` 来引用当前进程，它返回一个指向 `struct task_struct` 的指针，该结构由 `<linux/sched.h>` 定义。`current` 指针引用当前正在执行的进程。在执行系统调用（如 `open` 或 `read`）时，当前进程是调用该调用的进程。内核代码可以通过使用 `current` 来使用进程特定的信息，如果需要的话。第6章将展示这种技术的示例。

实际上，`current` 并不是真正的全局变量。支持 SMP 系统的需求迫使内核开发人员开发一种机制，以在相关 CPU 上找到当前进程。这种机制还必须快速，因为对 `current` 的引用频繁发生。结果是一种依赖于体系结构的机制，通常将指向 `task_struct` 结构的指针隐藏在内核堆栈上。实现的细节对其他内核子系统保持隐藏，设备驱动程序只需包含 `<linux/sched.h>` 并引用当前进程。例如，以下语句通过访问 `struct task_struct` 中的某些字段打印当前进程的进程 ID 和命令名称：

```c
printk(KERN_INFO "The process is \"%s\" (pid %i)\n",
       current->comm, current->pid);
```

存储在 `current->comm` 中的命令名称是当前进程正在执行的程序文件的基本名称（如果需要，则修剪为15个字符）。

## 其他一些细节

内核编程与用户空间编程在许多方面有所不同。我们将在本书中遇到这些问题时指出，但有一些基本问题虽然不值得单独一节，但值得一提。因此，当你深入研究内核时，应牢记以下问题。

应用程序在虚拟内存中布局，具有非常大的堆栈区域。堆栈当然用于保存函数调用历史记录和当前活动函数创建的所有自动变量。相反，内核的堆栈非常小；它可以小到单个4096字节的页面。你的函数必须与整个内核空间调用链共享该堆栈。因此，声明大型自动变量从来都不是一个好主意；如果你需要更大的结构，你应该在调用时动态分配它们。

通常，当你查看内核 API 时，你会遇到以双下划线（`__`）开头的函数名。如此标记的函数通常是接口的低级组件，应谨慎使用。本质上，双下划线对程序员说：“如果你调用这个函数，请确保你知道你在做什么。”

内核代码不能进行浮点运算。启用浮点运算将要求内核在每次进入和退出内核空间时保存和恢复浮点处理器的状态——至少在某些架构上是这样。鉴于内核代码中确实不需要浮点运算，额外的开销是不值得的。

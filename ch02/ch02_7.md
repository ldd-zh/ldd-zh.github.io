# 初始化和关闭

如前所述，模块初始化函数注册模块提供的任何功能。所谓功能，我们指的是新的功能，无论是整个驱动程序还是新的软件抽象，应用程序都可以访问。初始化函数的实际定义通常如下所示：

```c
static int __init initialization_function(void)
{
    /* 初始化代码 */
}
module_init(initialization_function);
```

初始化函数应声明为 `static`，因为它们不应在特定文件之外可见；虽然没有硬性规定，但没有函数会被显式导出到内核的其余部分。定义中的 `__init` 标记可能看起来有点奇怪；它是对内核的提示，表明给定的函数仅在初始化时使用。模块加载器在模块加载后丢弃初始化函数，使其内存可用于其他用途。对于仅在初始化期间使用的数据，也有类似的标记（`__initdata`）。使用 `__init` 和 `__initdata` 是可选的，但值得这样做。只需确保不要将它们用于初始化完成后将使用的任何函数（或数据结构）。你可能还会在内核源代码中遇到 `__devinit` 和 `__devinitdata`；这些仅在未配置为支持热插拔设备时转换为 `__init` 和 `__initdata`。我们将在第14章讨论热插拔支持。

使用 `module_init` 是强制性的。此宏将模块的目标代码中添加一个特殊部分，声明模块的初始化函数的位置。如果没有此定义，你的初始化函数将永远不会被调用。

模块可以注册许多不同类型的设施，包括不同类型的设备、文件系统、加密转换等。对于每种设施，都有一个特定的内核函数来完成此注册。传递给内核注册函数的参数通常是指向描述新设施的数据结构的指针和正在注册的设施的名称。数据结构通常包含指向模块函数的指针，这就是模块体中的函数如何被调用的方式。

可以注册的项目超出了第1章中提到的设备类型列表。它们包括串行端口、杂项设备、`sysfs` 条目、`/proc` 文件、可执行域和线路规程等。其中许多可注册项目支持的功能与硬件没有直接关系，但仍属于“软件抽象”领域。这些项目可以注册，因为它们无论如何都集成到驱动程序的功能中（例如 `/proc` 文件和线路规程）。

还有一些设施可以作为某些驱动程序的附加组件注册，但它们的使用非常特定，不值得讨论；它们使用堆叠技术，如“内核符号表”部分所述。如果你想进一步探索，可以在内核源代码中搜索 `EXPORT_SYMBOL`，并找到不同驱动程序提供的入口点。大多数注册函数都以 `register_` 为前缀，因此另一种可能的查找方法是搜索内核源代码中的 `register_`。

## 清理函数

每个非平凡的模块还需要一个清理函数，该函数在模块移除之前注销接口并将所有资源返回给系统。此函数定义如下：

```c
static void __exit cleanup_function(void)
{
    /* 清理代码 */
}
module_exit(cleanup_function);
```

清理函数没有返回值，因此声明为 `void`。`__exit` 修饰符将代码标记为仅用于模块卸载（通过使编译器将其放置在特殊的 ELF 部分中）。如果你的模块直接构建到内核中，或者如果你的内核配置为不允许卸载模块，标记为 `__exit` 的函数将被简单地丢弃。因此，标记为 `__exit` 的函数只能在模块卸载或系统关闭时调用；任何其他使用都是错误的。同样，`module_exit` 声明是必要的，以使内核能够找到你的清理函数。

如果你的模块没有定义清理函数，内核将不允许它被卸载。

## 初始化期间的错误处理

在向内核注册设施时，你必须始终记住注册可能会失败。即使是最简单的操作通常也需要内存分配，而所需的内存可能不可用。因此，模块代码必须始终检查返回值，并确保请求的操作实际成功。

如果在注册实用程序时发生任何错误，首要任务是决定模块是否可以继续初始化。通常，模块可以在注册失败后继续运行，必要时功能会有所降低。只要有可能，你的模块应在失败后继续前进，并提供它能够提供的功能。

如果事实证明你的模块在特定类型的失败后根本无法加载，你必须撤销在失败之前执行的任何注册活动。Linux 不会保留每个模块已注册设施的注册表，因此如果初始化在某个时刻失败，模块必须自行撤销所有操作。如果你未能注销你获得的内容，内核将处于不稳定状态；它包含指向不再存在的代码的内部指针。在这种情况下，通常唯一的办法是重新启动系统。你真的希望在发生初始化错误时小心处理。

错误恢复有时最好使用 `goto` 语句处理。我们通常不喜欢使用 `goto`，但在我们看来，这是它有用的一种情况。在错误情况下谨慎使用 `goto` 可以消除大量复杂的、高度缩进的“结构化”逻辑。因此，在内核中，`goto` 经常用于处理错误，如下所示。

以下示例代码（使用虚构的注册和注销函数）在初始化在任何时刻失败时表现正确：

```c
int __init my_init_function(void)
{
    int err;

    /* 注册需要一个指针和一个名称 */
    err = register_this(ptr1, "skull");
    if (err) goto fail_this;
    err = register_that(ptr2, "skull");
    if (err) goto fail_that;
    err = register_those(ptr3, "skull");
    if (err) goto fail_those;

    return 0; /* 成功 */

fail_those: unregister_that(ptr2, "skull");
fail_that: unregister_this(ptr1, "skull");
fail_this: return err; /* 传播错误 */
}
```

此代码尝试注册三个（虚构的）设施。`goto` 语句在失败时用于仅注销在出现问题之前已成功注册的设施。

另一种不需要复杂的 `goto` 语句的选项是跟踪已成功注册的内容，并在发生任何错误时调用模块的清理函数。清理函数仅撤销已成功完成的步骤。然而，这种替代方案需要更多的代码和更多的 CPU 时间，因此在快速路径中你仍然会使用 `goto` 作为最佳的错误恢复工具。

`my_init_function` 的返回值 `err` 是一个错误代码。在 Linux 内核中，错误代码是负数，属于 `<linux/errno.h>` 中定义的集合。如果你想生成自己的错误代码，而不是返回从其他函数获得的值，你应该包含 `<linux/errno.h>`，以便使用诸如 `-ENODEV`、`-ENOMEM` 等符号值。返回适当的错误代码始终是一个好习惯，因为用户程序可以使用 `perror` 或类似方法将其转换为有意义的字符串。

显然，模块的清理函数必须撤销初始化函数执行的任何注册操作，通常（但不总是强制性的）以与注册顺序相反的顺序注销设施：

```c
void __exit my_cleanup_function(void)
{
    unregister_those(ptr3, "skull");
    unregister_that(ptr2, "skull");
    unregister_this(ptr1, "skull");
    return;
}
```

如果你的初始化和清理比处理几个项目更复杂，`goto` 方法可能会变得难以管理，因为所有清理代码必须在初始化函数中重复，并混合多个标签。因此，有时不同的代码布局会更为成功。

为了最小化代码重复并保持一切简洁，你可以在发生错误时从初始化函数中调用清理函数。然后，清理函数必须在撤销注册之前检查每个项目的状态。在最简单的形式中，代码如下所示：

```c
struct something *item1;
struct somethingelse *item2;
int stuff_ok;

void my_cleanup(void)
{
    if (item1)
        release_thing(item1);
    if (item2)
        release_thing2(item2);
    if (stuff_ok)
        unregister_stuff();
    return;
}

int __init my_init(void)
{
    int err = -ENOMEM;

    item1 = allocate_thing(arguments);
    item2 = allocate_thing2(arguments2);
    if (!item1 || !item2)
        goto fail;
    err = register_stuff(item1, item2);
    if (!err)
        stuff_ok = 1;
    else
        goto fail;
    return 0; /* 成功 */

fail:
    my_cleanup();
    return err;
}
```

如这段代码所示，你可能需要外部标志来标记初始化步骤的成功，具体取决于你调用的注册/分配函数的语义。无论是否需要标志，这种初始化方式都可以很好地扩展到大量项目，并且通常比前面展示的技术更好。请注意，当清理函数被非退出代码调用时（如前面的示例），它不能标记为 `__exit`。

## 模块加载竞争

到目前为止，我们的讨论忽略了一个重要的模块加载问题：竞争条件。如果你不小心编写初始化函数，可能会创建危及整个系统稳定性的情况。我们将在本书后面讨论竞争条件；现在，几个要点就足够了。

首先，你应该始终记住，内核的其他部分可以在你注册任何设施后立即使用它。换句话说，内核可能会在你的初始化函数仍在运行时调用你的模块。因此，你的代码必须准备好在完成第一次注册后立即被调用。在支持该设施所需的所有内部初始化完成之前，不要注册任何设施。

你还必须考虑如果你的初始化函数决定失败，但内核的某些部分已经在使用你的模块注册的设施时会发生什么。如果这种情况对你的模块是可能的，你应该认真考虑根本不使初始化失败。毕竟，模块显然已经成功导出了有用的东西。如果初始化必须失败，它必须小心地绕过内核中可能正在进行的任何操作，直到这些操作完成。

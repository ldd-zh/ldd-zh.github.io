<!DOCTYPE html> <html><head>
		<title>3.3 一些重要的数据结构</title>
		<base href="../">
		<meta id="root-path" root-path="../">
		<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes, minimum-scale=1.0, maximum-scale=5.0">
		<meta charset="UTF-8">
		<meta name="description" content="ldd_zh - 3.3 一些重要的数据结构">
		<meta property="og:title" content="3.3 一些重要的数据结构">
		<meta property="og:description" content="ldd_zh - 3.3 一些重要的数据结构">
		<meta property="og:type" content="website">
		<meta property="og:url" content="第3章-字符设备驱动/3.3-一些重要的数据结构.html">
		<meta property="og:image" content="undefined">
		<meta property="og:site_name" content="ldd_zh">
		<link rel="alternate" type="application/rss+xml" title="RSS Feed" href="lib/rss.xml"><script async="" id="webpage-script" src="lib/scripts/webpage.js" onload="this.onload=null;this.setAttribute(&quot;loaded&quot;, &quot;true&quot;)"></script><script type="module" async="" id="graph-view-script" src="lib/scripts/graph-view.js"></script><script async="" id="graph-wasm-script" src="lib/scripts/graph-wasm.js" onload="this.onload=null;this.setAttribute(&quot;loaded&quot;, &quot;true&quot;)"></script><script async="" id="graph-render-worker-script" src="lib/scripts/graph-render-worker.js" onload="this.onload=null;this.setAttribute(&quot;loaded&quot;, &quot;true&quot;)"></script><script async="" id="tinycolor-script" src="lib/scripts/tinycolor.js" onload="this.onload=null;this.setAttribute(&quot;loaded&quot;, &quot;true&quot;)"></script><script async="" id="pixi-script" src="https://cdnjs.cloudflare.com/ajax/libs/pixi.js/7.4.0/pixi.min.js" onload="this.onload=null;this.setAttribute(&quot;loaded&quot;, &quot;true&quot;)"></script><script async="" id="minisearch-script" src="https://cdn.jsdelivr.net/npm/minisearch@6.3.0/dist/umd/index.min.js" onload="this.onload=null;this.setAttribute(&quot;loaded&quot;, &quot;true&quot;)"></script><link rel="icon" href="lib/media/favicon.png"><script async="" id="graph-data-script" src="lib/scripts/graph-data.js" onload="this.onload=null;this.setAttribute(&quot;loaded&quot;, &quot;true&quot;)"></script><style>body{--line-width:40em;--line-width-adaptive:40em;--file-line-width:40em;--sidebar-width:min(20em, 80vw);--collapse-arrow-size:11px;--tree-horizontal-spacing:0.6em;--tree-vertical-spacing:0.6em;--sidebar-margin:12px}.sidebar{height:100%;min-width:calc(var(--sidebar-width) + var(--divider-width-hover));max-width:calc(var(--sidebar-width) + var(--divider-width-hover));font-size:14px;z-index:10;position:relative;overflow:hidden;transition:min-width ease-in-out,max-width ease-in-out;transition-duration:.2s;contain:size}.sidebar-left{left:0}.sidebar-right{right:0}.sidebar.is-collapsed{min-width:0;max-width:0}body.floating-sidebars .sidebar{position:absolute}.sidebar-content{height:100%;min-width:calc(var(--sidebar-width) - var(--divider-width-hover));top:0;padding:var(--sidebar-margin);padding-top:4em;line-height:var(--line-height-tight);background-color:var(--background-secondary);transition:background-color,border-right,border-left,box-shadow;transition-duration:var(--color-fade-speed);transition-timing-function:ease-in-out;position:absolute;display:flex;flex-direction:column}.sidebar:not(.is-collapsed) .sidebar-content{min-width:calc(max(100%,var(--sidebar-width)) - 3px);max-width:calc(max(100%,var(--sidebar-width)) - 3px)}.sidebar-left .sidebar-content{left:0;border-top-right-radius:var(--radius-l);border-bottom-right-radius:var(--radius-l)}.sidebar-right .sidebar-content{right:0;border-top-left-radius:var(--radius-l);border-bottom-left-radius:var(--radius-l)}.sidebar:has(.sidebar-content:empty):has(.topbar-content:empty){display:none}.sidebar-topbar{height:2em;width:var(--sidebar-width);top:var(--sidebar-margin);padding-inline:var(--sidebar-margin);z-index:1;position:fixed;display:flex;align-items:center;transition:width ease-in-out;transition-duration:inherit}.sidebar.is-collapsed .sidebar-topbar{width:calc(2.3em + var(--sidebar-margin) * 2)}.sidebar .sidebar-topbar.is-collapsed{width:0}.sidebar-left .sidebar-topbar{left:0}.sidebar-right .sidebar-topbar{right:0}.topbar-content{overflow:hidden;overflow:clip;width:100%;height:100%;display:flex;align-items:center;transition:inherit}.sidebar.is-collapsed .topbar-content{width:0;transition:inherit}.clickable-icon.sidebar-collapse-icon{background-color:transparent;color:var(--icon-color-focused);padding:0!important;margin:0!important;height:100%!important;width:2.3em!important;margin-inline:0.14em!important;position:absolute}.sidebar-left .clickable-icon.sidebar-collapse-icon{transform:rotateY(180deg);right:var(--sidebar-margin)}.sidebar-right .clickable-icon.sidebar-collapse-icon{transform:rotateY(180deg);left:var(--sidebar-margin)}.clickable-icon.sidebar-collapse-icon svg.svg-icon{width:100%;height:100%}.sidebar-section-header{margin:0 0 1em 0;text-transform:uppercase;letter-spacing:.06em;font-weight:600}body{transition:background-color var(--color-fade-speed) ease-in-out}.webpage-container{display:flex;flex-direction:row;height:100%;width:100%;align-items:stretch;justify-content:center}.document-container{opacity:1;flex-basis:100%;max-width:100%;width:100%;height:100%;display:flex;flex-direction:column;align-items:center;transition:opacity .2s ease-in-out;contain:inline-size}.hide{opacity:0;transition:opacity .2s ease-in-out}.document-container>.markdown-preview-view{margin:var(--sidebar-margin);margin-bottom:0;width:100%;width:-webkit-fill-available;width:-moz-available;width:fill-available;background-color:var(--background-primary);transition:background-color var(--color-fade-speed) ease-in-out;border-top-right-radius:var(--window-radius,var(--radius-m));border-top-left-radius:var(--window-radius,var(--radius-m));overflow-x:hidden!important;overflow-y:auto!important;display:flex!important;flex-direction:column!important;align-items:center!important;contain:inline-size}.document-container>.markdown-preview-view>.markdown-preview-sizer{padding-bottom:80vh!important;width:100%!important;max-width:var(--line-width)!important;flex-basis:var(--line-width)!important;transition:background-color var(--color-fade-speed) ease-in-out;contain:inline-size}.markdown-rendered img:not([width]),.view-content img:not([width]){max-width:100%;outline:0}.document-container>.view-content.embed{display:flex;padding:1em;height:100%;width:100%;align-items:center;justify-content:center}.document-container>.view-content.embed>*{max-width:100%;max-height:100%;object-fit:contain}:has(> :is(.math,table)){overflow-x:auto!important}.document-container>.view-content{overflow-x:auto;contain:content;padding:0;margin:0;height:100%}.scroll-highlight{position:absolute;width:100%;height:100%;pointer-events:none;z-index:1000;background-color:hsla(var(--color-accent-hsl),.25);opacity:0;padding:1em;inset:50%;translate:-50% -50%;border-radius:var(--radius-s)}</style><script defer="">async function loadIncludes(){if("file:"!=location.protocol){let e=document.querySelectorAll("include");for(let t=0;t<e.length;t++){let o=e[t],l=o.getAttribute("src");try{const e=await fetch(l);if(!e.ok){console.log("Could not include file: "+l),o?.remove();continue}let t=await e.text(),n=document.createRange().createContextualFragment(t),i=Array.from(n.children);for(let e of i)e.classList.add("hide"),e.style.transition="opacity 0.5s ease-in-out",setTimeout((()=>{e.classList.remove("hide")}),10);o.before(n),o.remove(),console.log("Included file: "+l)}catch(e){o?.remove(),console.log("Could not include file: "+l,e);continue}}}else{if(document.querySelectorAll("include").length>0){var e=document.createElement("div");e.id="error",e.textContent="Web server exports must be hosted on an http / web server to be viewed correctly.",e.style.position="fixed",e.style.top="50%",e.style.left="50%",e.style.transform="translate(-50%, -50%)",e.style.fontSize="1.5em",e.style.fontWeight="bold",e.style.textAlign="center",document.body.appendChild(e),document.querySelector(".document-container")?.classList.remove("hide")}}}document.addEventListener("DOMContentLoaded",(()=>{loadIncludes()}));let isFileProtocol="file:"==location.protocol;function waitLoadScripts(e,t){let o=e.map((e=>document.getElementById(e+"-script"))),l=0;!function e(){let n=o[l];l++,n&&"true"!=n.getAttribute("loaded")||l<o.length&&e(),l<o.length?n.addEventListener("load",e):t()}()}</script><link rel="stylesheet" href="lib/styles/obsidian.css"><link rel="stylesheet" href="lib/styles/theme.css"><link rel="preload" href="lib/styles/global-variable-styles.css" as="style" onload="this.onload=null;this.rel='stylesheet'"><noscript><link rel="stylesheet" href="lib/styles/global-variable-styles.css"></noscript><link rel="preload" href="lib/styles/main-styles.css" as="style" onload="this.onload=null;this.rel='stylesheet'"><noscript><link rel="stylesheet" href="lib/styles/main-styles.css"></noscript></head><body class="publish css-settings-manager native-scrollbars theme-light show-inline-title show-ribbon"><script defer="">let theme=localStorage.getItem("theme")||(window.matchMedia("(prefers-color-scheme: dark)").matches?"dark":"light");"dark"==theme?(document.body.classList.add("theme-dark"),document.body.classList.remove("theme-light")):(document.body.classList.add("theme-light"),document.body.classList.remove("theme-dark")),window.innerWidth<480?document.body.classList.add("is-phone"):window.innerWidth<768?document.body.classList.add("is-tablet"):window.innerWidth<1024?document.body.classList.add("is-small-screen"):document.body.classList.add("is-large-screen")</script><div class="webpage-container workspace"><div class="sidebar-left sidebar"><div class="sidebar-handle"></div><div class="sidebar-topbar"><div class="topbar-content"><label class="theme-toggle-container" for="theme_toggle"><input class="theme-toggle-input" type="checkbox" id="theme_toggle"><div class="toggle-background"></div></label></div><div class="clickable-icon sidebar-collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="100%" height="100%" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="3" stroke-linecap="round" stroke-linejoin="round" class="svg-icon"><path d="M21 3H3C1.89543 3 1 3.89543 1 5V19C1 20.1046 1.89543 21 3 21H21C22.1046 21 23 20.1046 23 19V5C23 3.89543 22.1046 3 21 3Z"></path><path d="M10 4V20"></path><path d="M4 7H7"></path><path d="M4 10H7"></path><path d="M4 13H7"></path></svg></div></div><div class="sidebar-content"><div class="search-input-container"><input enterkeyhint="search" type="search" spellcheck="false" placeholder="Search..."><div class="search-input-clear-button" aria-label="Clear search"></div></div><include src="lib/html/file-tree.html"></include></div><script defer="">let ls = document.querySelector(".sidebar-left"); ls.classList.add("is-collapsed"); if (window.innerWidth > 768) ls.classList.remove("is-collapsed"); ls.style.setProperty("--sidebar-width", localStorage.getItem("sidebar-left-width"));</script></div><div class="document-container markdown-reading-view hide"><div class="markdown-preview-view markdown-rendered allow-fold-headings allow-fold-lists is-readable-line-width"><style id="MJX-CHTML-styles"></style><div class="markdown-preview-sizer markdown-preview-section"><h1 class="page-title heading inline-title" id="3.3 一些重要的数据结构">3.3 一些重要的数据结构</h1><div class="el-p"><p dir="auto">正如你所想象的，设备号注册只是驱动代码必须执行的众多任务中的第一个。我们很快会查看其他重要的驱动组件，但首先需要另一个插曲。大多数基本的驱动操作涉及三个重要的内核数据结构，称为 <code>file_operations</code>、<code>file</code> 和 <code>inode</code>。要能够做任何有趣的事情，必须对这些结构有基本的了解，因此我们现在将快速查看每个结构，然后再详细介绍如何实现基本的驱动操作。</p></div><div class="el-h2 heading-wrapper"><h2 data-heading="文件操作" dir="auto" class="heading" id="文件操作"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>文件操作</h2><div class="heading-children"><div class="el-p"><p dir="auto">到目前为止，我们已经为设备预留了一些设备号，但尚未将驱动程序的任何操作与这些设备号关联起来。<code>file_operations</code> 结构体是字符驱动程序用来建立这种连接的机制。该结构体定义在 <code>&lt;linux/fs.h&gt;</code> 中，是一个函数指针的集合。每个打开的文件（在内部由 <code>file</code> 结构体表示，稍后我们会详细讨论）都通过一个名为 <code>f_op</code> 的字段与一组函数关联起来，该字段指向一个 <code>file_operations</code> 结构体。这些操作主要负责实现系统调用，因此被命名为 <code>open</code>、<code>read</code> 等。我们可以将文件视为一个“对象”，而操作它的函数则是它的“方法”，这是我们在 Linux 内核中看到的第一个面向对象编程的迹象，后续章节中还会看到更多。</p></div><div class="el-p"><p dir="auto">通常，<code>file_operations</code> 结构体或其指针被称为 <code>fops</code>（或类似的名称）。结构体中的每个字段必须指向驱动程序中实现特定操作的函数，或者对于不支持的操作，可以留空（即设置为 <code>NULL</code>）。当指定 <code>NULL</code> 指针时，内核的确切行为因函数而异，本节后面的列表会详细说明。</p></div><div class="el-p"><p dir="auto">以下列表介绍了应用程序可以在设备上调用的所有操作。我们尽量保持列表简洁，以便作为参考，仅总结每个操作以及当使用 <code>NULL</code> 指针时的默认内核行为。在阅读 <code>file_operations</code> 方法列表时，你会注意到许多参数包含 <code>__user</code> 字符串。这个注解是一种文档形式，用于说明指针是用户空间地址，不能直接解引用。在正常编译时，<code>__user</code> 没有实际作用，但它可以被外部检查工具用来发现用户空间地址的误用。</p></div><div class="el-p"><p dir="auto">在本章的其余部分，我们将描述一些其他重要的数据结构，解释最重要操作的作用，并提供提示、注意事项和实际代码示例。我们将更复杂操作的讨论推迟到后面的章节，因为目前还不适合深入探讨内存管理、阻塞操作和异步通知等主题。</p></div><div class="el-ul"><ul>
<li data-line="0" dir="auto"><code>struct module *owner</code></li>
</ul></div><div class="el-p"><p dir="auto"><code>file_operations</code> 结构体的第一个字段并不是一个操作，而是一个指向“拥有”该结构体的模块的指针。该字段用于防止模块在其操作仍在使用时被卸载。大多数情况下，它只需初始化为 <code>THIS_MODULE</code>，这是一个定义在 <code>&lt;linux/module.h&gt;</code> 中的宏。</p></div><div class="el-ul"><ul>
<li data-line="0" dir="auto"><code>loff_t (*llseek) (struct file *, loff_t, int);</code></li>
</ul></div><div class="el-p"><p dir="auto"><code>llseek</code> 方法用于更改文件中的当前读/写位置，并将新位置作为（正数）返回值返回。<code>loff_t</code> 参数是一个“长偏移量”，即使在 32 位平台上也至少为 64 位宽。错误通过负返回值表示。如果该函数指针为 <code>NULL</code>，<code>seek</code> 调用将以可能不可预测的方式修改 <code>file</code> 结构体中的位置计数器。</p></div><div class="el-ul"><ul>
<li data-line="0" dir="auto"><code>ssize_t (*read) (struct file *, char __user *, size_t, loff_t *);</code></li>
</ul></div><div class="el-p"><p dir="auto">用于从设备中检索数据。如果该字段为 <code>NULL</code>，<code>read</code> 系统调用将返回 <code>-EINVAL</code>（“无效参数”）。非负返回值表示成功读取的字节数（返回值是一个“有符号大小”类型，通常是目标平台的原生整数类型）。</p></div><div class="el-ul"><ul>
<li data-line="0" dir="auto"><code>ssize_t (*aio_read)(struct kiocb *, char __user *, size_t, loff_t);</code></li>
</ul></div><div class="el-p"><p dir="auto">启动异步读取操作——该操作可能在函数返回之前未完成。如果该字段为 <code>NULL</code>，所有操作将由 <code>read</code> 方法同步处理。</p></div><div class="el-ul"><ul>
<li data-line="0" dir="auto"><code>ssize_t (*write) (struct file *, const char __user *, size_t, loff_t *);</code></li>
</ul></div><div class="el-p"><p dir="auto">向设备发送数据。如果该字段为 <code>NULL</code>，<code>write</code> 系统调用将返回 <code>-EINVAL</code>。非负返回值表示成功写入的字节数。</p></div><div class="el-ul"><ul>
<li data-line="0" dir="auto"><code>ssize_t (*aio_write)(struct kiocb *, const char __user *, size_t, loff_t *);</code></li>
</ul></div><div class="el-p"><p dir="auto">启动设备上的异步写入操作。</p></div><div class="el-ul"><ul>
<li data-line="0" dir="auto"><code>int (*readdir) (struct file *, void *, filldir_t);</code></li>
</ul></div><div class="el-p"><p dir="auto">该字段对于设备文件应为 <code>NULL</code>，它用于读取目录，仅对文件系统有用。</p></div><div class="el-ul"><ul>
<li data-line="0" dir="auto"><code>unsigned int (*poll) (struct file *, struct poll_table_struct *);</code></li>
</ul></div><div class="el-p"><p dir="auto"><code>poll</code> 方法是 <code>poll</code>、<code>epoll</code> 和 <code>select</code> 系统调用的后端，这些系统调用用于查询对一个或多个文件描述符的读/写操作是否会阻塞。<code>poll</code> 方法应返回一个位掩码，指示是否可以进行非阻塞读/写操作，并可能向内核提供信息，以便在 I/O 操作可能时将调用进程置于睡眠状态。如果驱动程序将 <code>poll</code> 方法设置为 <code>NULL</code>，则假定设备既可读又可写且不会阻塞。</p></div><div class="el-ul"><ul>
<li data-line="0" dir="auto"><code>int (*ioctl) (struct inode *, struct file *, unsigned int, unsigned long);</code></li>
</ul></div><div class="el-p"><p dir="auto"><code>ioctl</code> 系统调用提供了一种发出设备特定命令的方式（例如格式化软盘的一个磁道，这既不是读也不是写）。此外，内核会识别一些 <code>ioctl</code> 命令，而无需参考 <code>fops</code> 表。如果设备未提供 <code>ioctl</code> 方法，则对于任何未预定义的请求，系统调用将返回错误（<code>-ENOTTY</code>，“设备没有此类 ioctl”）。</p></div><div class="el-ul"><ul>
<li data-line="0" dir="auto"><code>int (*mmap) (struct file *, struct vm_area_struct *);</code></li>
</ul></div><div class="el-p"><p dir="auto"><code>mmap</code> 用于请求将设备内存映射到进程的地址空间。如果该字段为 <code>NULL</code>，<code>mmap</code> 系统调用将返回 <code>-ENODEV</code>。</p></div><div class="el-ul"><ul>
<li data-line="0" dir="auto"><code>int (*open) (struct inode *, struct file *);</code></li>
</ul></div><div class="el-p"><p dir="auto">尽管这是对设备文件执行的第一个操作，但驱动程序不需要声明相应的方法。如果该字段为 <code>NULL</code>，打开设备将始终成功，但驱动程序不会收到通知。</p></div><div class="el-ul"><ul>
<li data-line="0" dir="auto"><code>int (*flush) (struct file *);</code></li>
</ul></div><div class="el-p"><p dir="auto">当进程关闭其设备文件描述符的副本时，会调用 <code>flush</code> 操作；它应执行（并等待）设备上的任何未完成操作。这不应与用户程序请求的 <code>fsync</code> 操作混淆。目前，<code>flush</code> 仅在少数驱动程序中使用；例如，SCSI 磁带驱动程序使用它来确保在设备关闭之前将所有写入的数据写入磁带。如果 <code>flush</code> 为 <code>NULL</code>，内核将忽略用户应用程序的请求。</p></div><div class="el-ul"><ul>
<li data-line="0" dir="auto"><code>int (*release) (struct inode *, struct file *);</code></li>
</ul></div><div class="el-p"><p dir="auto">当释放 <code>file</code> 结构体时，会调用此操作。与 <code>open</code> 一样，<code>release</code> 可以为 <code>NULL</code>。</p></div><div class="el-ul"><ul>
<li data-line="0" dir="auto"><code>int (*fsync) (struct file *, struct dentry *, int);</code></li>
</ul></div><div class="el-p"><p dir="auto">该方法是 <code>fsync</code> 系统调用的后端，用户调用该系统调用来刷新任何挂起的数据。如果该字段为 <code>NULL</code>，系统调用将返回 <code>-EINVAL</code>。</p></div><div class="el-ul"><ul>
<li data-line="0" dir="auto"><code>int (*aio_fsync)(struct kiocb *, int);</code></li>
</ul></div><div class="el-p"><p dir="auto">这是 <code>fsync</code> 方法的异步版本。</p></div><div class="el-ul"><ul>
<li data-line="0" dir="auto"><code>int (*fasync) (int, struct file *, int);</code></li>
</ul></div><div class="el-p"><p dir="auto">该操作用于通知设备其 <code>FASYNC</code> 标志的更改。异步通知是一个高级主题，将在第 6 章中描述。如果驱动程序不支持异步通知，该字段可以为 <code>NULL</code>。</p></div><div class="el-ul"><ul>
<li data-line="0" dir="auto"><code>int (*lock) (struct file *, int, struct file_lock *);</code></li>
</ul></div><div class="el-p"><p dir="auto"><code>lock</code> 方法用于实现文件锁定；锁定是常规文件不可或缺的功能，但设备驱动程序几乎从不实现它。</p></div><div class="el-ul"><ul>
<li data-line="0" dir="auto"><code>ssize_t (*readv) (struct file *, const struct iovec *, unsigned long, loff_t*);</code></li>
<li data-line="1" dir="auto"><code>ssize_t (*writev) (struct file *, const struct iovec *, unsigned long, loff_t *);</code></li>
</ul></div><div class="el-p"><p dir="auto">这些方法实现了分散/聚集读/写操作。应用程序有时需要对多个内存区域执行单个读/写操作；这些系统调用允许它们在不强制对数据进行额外复制操作的情况下完成此操作。如果这些函数指针为 <code>NULL</code>，则将调用 <code>read</code> 和 <code>write</code> 方法（可能多次）。</p></div><div class="el-ul"><ul>
<li data-line="0" dir="auto"><code>ssize_t (*sendfile)(struct file *, loff_t *, size_t, read_actor_t, void *);</code></li>
</ul></div><div class="el-p"><p dir="auto">该方法实现了 <code>sendfile</code> 系统调用的读取端，该系统调用以最少的复制将数据从一个文件描述符移动到另一个文件描述符。例如，Web 服务器使用它来将文件内容发送到网络连接。设备驱动程序通常将 <code>sendfile</code> 设置为 <code>NULL</code>。</p></div><div class="el-ul"><ul>
<li data-line="0" dir="auto"><code>ssize_t (*sendpage) (struct file *, struct page *, int, size_t, loff_t *, int);</code></li>
</ul></div><div class="el-p"><p dir="auto"><code>sendpage</code> 是 <code>sendfile</code> 的另一半；内核调用它以逐页的方式将数据发送到相应的文件。设备驱动程序通常不实现 <code>sendpage</code>。</p></div><div class="el-ul"><ul>
<li data-line="0" dir="auto"><code>unsigned long (*get_unmapped_area)(struct file *, unsigned long, unsigned long, unsigned long, unsigned long);</code></li>
</ul></div><div class="el-p"><p dir="auto">该方法的目的是在进程的地址空间中找到一个合适的位置来映射底层设备的内存段。此任务通常由内存管理代码执行；该方法的存在是为了允许驱动程序强制执行特定设备可能具有的任何对齐要求。大多数驱动程序可以将此方法设置为 <code>NULL</code>。</p></div><div class="el-ul"><ul>
<li data-line="0" dir="auto"><code>int (*check_flags)(int);</code></li>
</ul></div><div class="el-p"><p dir="auto">该方法允许模块检查传递给 <code>fcntl(F_SETFL...)</code> 调用的标志。</p></div><div class="el-ul"><ul>
<li data-line="0" dir="auto"><code>int (*dir_notify)(struct file *, unsigned long);</code></li>
</ul></div><div class="el-p"><p dir="auto">当应用程序使用 <code>fcntl</code> 请求目录更改通知时，会调用此方法。它仅对文件系统有用；驱动程序无需实现 <code>dir_notify</code>。</p></div><div class="el-p"><p dir="auto"><code>scull</code> 设备驱动程序仅实现了最重要的设备方法。其 <code>file_operations</code> 结构体初始化如下：</p></div><div class="el-pre"><pre class="language-c" tabindex="0"><code data-line="0" class="language-c is-loaded"><span class="token keyword">struct</span> <span class="token class-name">file_operations</span> scull_fops <span class="token operator">=</span> <span class="token punctuation">{</span>
    <span class="token punctuation">.</span>owner <span class="token operator">=</span> THIS_MODULE<span class="token punctuation">,</span>
    <span class="token punctuation">.</span>llseek <span class="token operator">=</span> scull_llseek<span class="token punctuation">,</span>
    <span class="token punctuation">.</span>read <span class="token operator">=</span> scull_read<span class="token punctuation">,</span>
    <span class="token punctuation">.</span>write <span class="token operator">=</span> scull_write<span class="token punctuation">,</span>
    <span class="token punctuation">.</span>ioctl <span class="token operator">=</span> scull_ioctl<span class="token punctuation">,</span>
    <span class="token punctuation">.</span>open <span class="token operator">=</span> scull_open<span class="token punctuation">,</span>
    <span class="token punctuation">.</span>release <span class="token operator">=</span> scull_release<span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code><button class="copy-code-button"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon lucide-copy"><rect x="8" y="8" width="14" height="14" rx="2" ry="2"></rect><path d="M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2"></path></svg></button></pre></div><div class="el-p"><p dir="auto">此声明使用了标准的 C 标记结构体初始化语法。这种语法是首选，因为它使驱动程序在结构体定义更改时更具可移植性，并且可以说使代码更紧凑和易读。标记初始化允许结构体成员的重新排序；在某些情况下，通过将频繁访问的成员指针放置在同一硬件缓存行中，可以实现显著的性能提升。</p></div></div></div><div class="el-h2 heading-wrapper"><h2 data-heading="文件结构" dir="auto" class="heading" id="文件结构"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>文件结构</h2><div class="heading-children"><div class="el-p"><p dir="auto"><code>struct file</code> 定义在 &lt;linux/fs.h&gt; 中，是设备驱动中使用的第二个最重要的数据结构。请注意，<code>file</code> 与用户空间程序的 <code>FILE</code> 指针无关。<code>FILE</code> 在 C 库中定义，永远不会出现在内核代码中。另一方面，<code>struct file</code> 是一个内核结构，永远不会出现在用户程序中。</p></div><div class="el-p"><p dir="auto"><code>file</code> 结构表示一个打开的文件。（它不特定于设备驱动；系统中的每个打开文件在内核空间中都有一个关联的 <code>struct file</code>。）它在打开时由内核创建，并传递给任何操作文件的函数，直到最后一次关闭。在所有文件实例关闭后，内核释放该数据结构。</p></div><div class="el-p"><p dir="auto">在内核源代码中，指向 <code>struct file</code> 的指针通常称为 <code>file</code> 或 <code>filp</code>（“文件指针”）。我们将一致地称指针为 <code>filp</code>，以防止与结构本身产生歧义。因此，<code>file</code> 指结构，<code>filp</code> 指指向结构的指针。</p></div><div class="el-p"><p dir="auto"><code>struct file</code> 的最重要字段如下所示。与上一节一样，列表可以在第一次阅读时跳过。然而，在本章后面，当我们面对一些真实的 C 代码时，我们将更详细地讨论这些字段。</p></div><div class="el-ul"><ul>
<li data-line="0" dir="auto"><code>mode_t f_mode</code>：</li>
</ul></div><div class="el-p"><p dir="auto">文件模式标识文件是可读、可写还是两者兼有，通过 <code>FMODE_READ</code> 和 <code>FMODE_WRITE</code> 位。你可能希望在 <code>open</code> 或 <code>ioctl</code> 函数中检查此字段以获取读/写权限，但你不需要为 <code>read</code> 和 <code>write</code> 检查权限，因为内核在调用你的方法之前会进行检查。如果文件未以该类型访问打开，尝试读取或写入将被拒绝，而驱动甚至不会知道。</p></div><div class="el-ul"><ul>
<li data-line="0" dir="auto"><code>loff_t f_pos</code>：</li>
</ul></div><div class="el-p"><p dir="auto">当前的读取或写入位置。<code>loff_t</code> 在所有平台上都是 64 位值（在 gcc 术语中为 <code>long long</code>）。如果需要知道文件中的当前位置，驱动可以读取此值，但通常不应更改它；<code>read</code> 和 <code>write</code> 应使用它们接收的指针作为最后一个参数来更新位置，而不是直接操作 <code>filp-&gt;f_pos</code>。此规则的一个例外是 <code>llseek</code> 方法，其目的是更改文件位置。</p></div><div class="el-ul"><ul>
<li data-line="0" dir="auto"><code>unsigned int f_flags</code>：</li>
</ul></div><div class="el-p"><p dir="auto">这些是文件标志，如 <code>O_RDONLY</code>、<code>O_NONBLOCK</code> 和 <code>O_SYNC</code>。驱动应检查 <code>O_NONBLOCK</code> 标志以查看是否已请求非阻塞操作（我们将在第1章的“阻塞和非阻塞操作”部分讨论非阻塞 I/O）；其他标志很少使用。特别是，应使用 <code>f_mode</code> 而不是 <code>f_flags</code> 检查读/写权限。所有标志都在头文件 &lt;linux/fcntl.h&gt; 中定义。</p></div><div class="el-ul"><ul>
<li data-line="0" dir="auto"><code>struct file_operations *f_op</code>：</li>
</ul></div><div class="el-p"><p dir="auto">与文件关联的操作。内核在实现 <code>open</code> 时分配指针，然后在需要分派任何操作时读取它。内核不会保存 <code>fillp-&gt;f_op</code> 的值以供以后参考；这意味着你可以更改与文件关联的文件操作，并且在你返回调用者后，新方法将生效。例如，与主设备号 1 关联的 <code>open</code> 代码（/dev/null、/dev/zero 等）根据打开的次设备号替换 <code>fillp-&gt;f_op</code> 中的操作。这种做法允许在同一个主设备号下实现多种行为，而不会在每次系统调用时引入开销。替换文件操作的能力是内核中“方法重写”的等价物，类似于面向对象编程中的概念。</p></div><div class="el-ul"><ul>
<li data-line="0" dir="auto"><code>void *private_data</code>：</li>
</ul></div><div class="el-p"><p dir="auto"><code>open</code> 系统调用在调用驱动的 <code>open</code> 方法之前将此指针设置为 <code>NULL</code>。你可以自由地使用该字段或忽略它；你可以使用该字段指向分配的数据，但必须记得在 <code>release</code> 方法中释放该内存，以免内核销毁文件结构时造成内存泄漏。<code>private_data</code> 是跨系统调用保存状态信息的有用资源，大多数示例模块都使用它。</p></div><div class="el-ul"><ul>
<li data-line="0" dir="auto"><code>struct dentry *f_dentry</code>：</li>
</ul></div><div class="el-p"><p dir="auto">与文件关联的目录项（<code>dentry</code>）结构。设备驱动编写者通常不需要关心 <code>dentry</code> 结构，除非需要访问 <code>inode</code> 结构，如 <code>fillp-&gt;f_dentry-&gt;d_inode</code>。</p></div><div class="el-p"><p dir="auto">实际的结构中还有更多字段，但它们对设备驱动没有用处。我们可以安全地忽略这些字段，因为驱动从不创建文件结构；它们只访问其他地方创建的结构。</p></div></div></div><div class="el-h2 heading-wrapper"><h2 data-heading="inode 结构" dir="auto" class="heading" id="inode_结构"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>inode 结构</h2><div class="heading-children"><div class="el-p"><p dir="auto"><code>inode</code> 结构由内核内部用于表示文件。因此，它与表示打开文件描述符的 <code>file</code> 结构不同。一个文件可以有多个 <code>file</code> 结构，表示多个打开的描述符，但它们都指向同一个 <code>inode</code> 结构。</p></div><div class="el-p"><p dir="auto"><code>inode</code> 结构包含大量关于文件的信息。通常，只有该结构的两个字段对编写驱动代码有意义：</p></div><div class="el-ul"><ul>
<li data-line="0" dir="auto"><code>dev_t i_rdev</code>：</li>
</ul></div><div class="el-p"><p dir="auto">对于表示设备文件的 <code>inode</code>，此字段包含实际的设备号。</p></div><div class="el-ul"><ul>
<li data-line="0" dir="auto"><code>struct cdev *i_cdev</code>：</li>
</ul></div><div class="el-p"><p dir="auto"><code>struct cdev</code> 是内核内部表示字符设备的结构；当 <code>inode</code> 引用字符设备文件时，此字段包含指向该结构的指针。</p></div><div class="el-p"><p dir="auto">在 2.5 开发系列的过程中，<code>i_rdev</code> 的类型发生了变化，导致许多驱动出现问题。为了鼓励更可移植的编程，内核开发者添加了两个宏，用于从 <code>inode</code> 中获取主设备号和次设备号：</p></div><div class="el-pre"><pre class="language-c" tabindex="0"><code data-line="0" class="language-c is-loaded"><span class="token keyword">unsigned</span> <span class="token keyword">int</span> <span class="token function">iminor</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">inode</span> <span class="token operator">*</span>inode<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">unsigned</span> <span class="token keyword">int</span> <span class="token function">imajor</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">inode</span> <span class="token operator">*</span>inode<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code><button class="copy-code-button"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon lucide-copy"><rect x="8" y="8" width="14" height="14" rx="2" ry="2"></rect><path d="M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2"></path></svg></button></pre></div><div class="el-p"><p dir="auto">为了避免被未来的变化所困扰，应使用这些宏，而不是直接操作 <code>i_rdev</code>。</p></div><div class="mod-footer mod-ui"></div></div></div></div></div></div><div class="sidebar-right sidebar"><div class="sidebar-handle"></div><div class="sidebar-topbar"><div class="topbar-content"></div><div class="clickable-icon sidebar-collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="100%" height="100%" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="3" stroke-linecap="round" stroke-linejoin="round" class="svg-icon"><path d="M21 3H3C1.89543 3 1 3.89543 1 5V19C1 20.1046 1.89543 21 3 21H21C22.1046 21 23 20.1046 23 19V5C23 3.89543 22.1046 3 21 3Z"></path><path d="M10 4V20"></path><path d="M4 7H7"></path><path d="M4 10H7"></path><path d="M4 13H7"></path></svg></div></div><div class="sidebar-content"><div class="graph-view-wrapper"><div class="sidebar-section-header">Interactive Graph</div><div class="graph-view-placeholder">
		<div class="graph-view-container">
			<div class="graph-icon graph-expand" role="button" aria-label="Expand" data-tooltip-position="top"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon"><line x1="7" y1="17" x2="17" y2="7"></line><polyline points="7 7 17 7 17 17"></polyline></svg></div>
			<canvas id="graph-canvas" class="hide" width="512px" height="512px"></canvas>
		</div>
		</div></div><div class="tree-container mod-root nav-folder tree-item outline-tree" data-depth="0"><div class="tree-header"><span class="sidebar-section-header">Table Of Contents</span><button class="clickable-icon collapse-tree-button" aria-label="Collapse All"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"></svg></button></div><div class="tree-scroll-area tree-item-children nav-folder-children"><div class="tree-item mod-tree-folder nav-folder mod-collapsible is-collapsed" style="display: none;"></div><div class="tree-item" data-depth="1"><a class="tree-link" href="第3章-字符设备驱动/3.3-一些重要的数据结构.html#3.3 一些重要的数据结构"><div class="tree-item-contents heading-link" heading-name="3.3 一些重要的数据结构"><span class="tree-item-title">3.3 一些重要的数据结构</span></div></a><div class="tree-item-children nav-folder-children"><div class="tree-item" data-depth="2"><a class="tree-link" href="第3章-字符设备驱动/3.3-一些重要的数据结构.html#文件操作"><div class="tree-item-contents heading-link" heading-name="文件操作"><span class="tree-item-title">文件操作</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="2"><a class="tree-link" href="第3章-字符设备驱动/3.3-一些重要的数据结构.html#文件结构"><div class="tree-item-contents heading-link" heading-name="文件结构"><span class="tree-item-title">文件结构</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="2"><a class="tree-link" href="第3章-字符设备驱动/3.3-一些重要的数据结构.html#inode_结构"><div class="tree-item-contents heading-link" heading-name="inode 结构"><span class="tree-item-title">inode 结构</span></div></a><div class="tree-item-children nav-folder-children"></div></div></div></div></div></div></div><script defer="">let rs = document.querySelector(".sidebar-right"); rs.classList.add("is-collapsed"); if (window.innerWidth > 768) rs.classList.remove("is-collapsed"); rs.style.setProperty("--sidebar-width", localStorage.getItem("sidebar-right-width"));</script></div></div></body></html>
# 一些重要的数据结构

正如你所想象的，设备号注册只是驱动代码必须执行的众多任务中的第一个。我们很快会查看其他重要的驱动组件，但首先需要另一个插曲。大多数基本的驱动操作涉及三个重要的内核数据结构，称为 file_operations、file 和 inode。要能够做任何有趣的事情，必须对这些结构有基本的了解，因此我们现在将快速查看每个结构，然后再详细介绍如何实现基本的驱动操作。

## 文件操作

到目前为止，我们已经为我们的使用保留了一些设备号，但尚未将我们的驱动的任何操作连接到这些号码。file_operations 结构是字符驱动设置此连接的方式。该结构定义在 <linux/fs.h> 中，是一个函数指针的集合。每个打开的文件（在内部由 file 结构表示，我们稍后会检查）都与其自己的一组函数相关联（通过包含一个名为 f_op 的字段，该字段指向一个 file_operations 结构）。这些操作主要负责实现系统调用，因此命名为 open、read 等。我们可以将文件视为一个“对象”，而操作它的函数是其“方法”，使用面向对象编程术语来表示对象声明的操作。这是我们在 Linux 内核中看到的第一个面向对象编程的迹象，我们将在后面的章节中看到更多。

通常，file_operations 结构或其指针称为 fops（或其变体）。结构中的每个字段必须指向驱动中实现特定操作的函数，或者对于不支持的操作留空。当指定 NULL 指针时，内核的确切行为因每个函数而异，如本节后面的列表所示。

以下列表介绍了应用程序可以在设备上调用的所有操作。我们尽量保持列表简短，以便可以用作参考，仅总结每个操作以及使用 NULL 指针时的默认内核行为。

## 文件结构

struct file 定义在 <linux/fs.h> 中，是设备驱动中使用的第二个最重要的数据结构。请注意，file 与用户空间程序的 FILE 指针无关。FILE 在 C 库中定义，永远不会出现在内核代码中。另一方面，struct file 是一个内核结构，永远不会出现在用户程序中。

file 结构表示一个打开的文件。（它不特定于设备驱动；系统中的每个打开文件在内核空间中都有一个关联的 struct file。）它在打开时由内核创建，并传递给任何操作文件的函数，直到最后一次关闭。在所有文件实例关闭后，内核释放该数据结构。

在内核源代码中，指向 struct file 的指针通常称为 file 或 filp（“文件指针”）。我们将一致地称指针为 filp，以防止与结构本身产生歧义。因此，file 指结构，filp 指指向结构的指针。

struct file 的最重要字段如下所示。与上一节一样，列表可以在第一次阅读时跳过。然而，在本章后面，当我们面对一些真实的 C 代码时，我们将更详细地讨论这些字段。

- **mode_t f_mode**：文件模式标识文件是可读、可写还是两者兼有，通过 FMODE_READ 和 FMODE_WRITE 位。你可能希望在 open 或 ioctl 函数中检查此字段以获取读/写权限，但你不需要为 read 和 write 检查权限，因为内核在调用你的方法之前会进行检查。如果文件未以该类型访问打开，尝试读取或写入将被拒绝，而驱动甚至不会知道。

- **loff_t f_pos**：当前的读取或写入位置。loff_t 在所有平台上都是 64 位值（在 gcc 术语中为 long long）。如果需要知道文件中的当前位置，驱动可以读取此值，但通常不应更改它；read 和 write 应使用它们接收的指针作为最后一个参数来更新位置，而不是直接操作 filp->f_pos。此规则的一个例外是 \textit{llseek} 方法，其目的是更改文件位置。

- **unsigned int f_flags**：这些是文件标志，如 0_RDONLY、0_NONBLOCK 和 0_SYNC。驱动应检查 0_NONBLOCK 标志以查看是否已请求非阻塞操作（我们将在第1章的“阻塞和非阻塞操作”部分讨论非阻塞 I/O）；其他标志很少使用。特别是，应使用 f_mode 而不是 f_flags 检查读/写权限。所有标志都在头文件 <\textit{linux/fcntl.h}> 中定义。

- **struct file_operations *f_op**：与文件关联的操作。内核在实现 open 时分配指针，然后在需要分派任何操作时读取它。内核不会保存 fillp->f_op 的值以供以后参考；这意味着你可以更改与文件关联的文件操作，并且在你返回调用者后，新方法将生效。例如，与主设备号 1 关联的 open 代码（\textit{dev/null}、\textit{dev/zero} 等）根据打开的次设备号替换 fillp->f_op 中的操作。这种做法允许在同一个主设备号下实现多种行为，而不会在每次系统调用时引入开销。替换文件操作的能力是内核中“方法重写”的等价物，类似于面向对象编程中的概念。

- **void *private_data**：open 系统调用在调用驱动的 open 方法之前将此指针设置为 NULL。你可以自由地使用该字段或忽略它；你可以使用该字段指向分配的数据，但必须记得在 release 方法中释放该内存，以免内核销毁文件结构时造成内存泄漏。private_data 是跨系统调用保存状态信息的有用资源，大多数示例模块都使用它。

- **struct dentry *f_dentry**：与文件关联的目录项（dentry）结构。设备驱动编写者通常不需要关心 dentry 结构，除非需要访问 inode 结构，如 fillp->f_dentry->d_inode。

实际的结构中还有更多字段，但它们对设备驱动没有用处。我们可以安全地忽略这些字段，因为驱动从不创建文件结构；它们只访问其他地方创建的结构。

## inode 结构

inode 结构由内核内部用于表示文件。因此，它与表示打开文件描述符的 file 结构不同。一个文件可以有多个 file 结构，表示多个打开的描述符，但它们都指向同一个 inode 结构。

inode 结构包含大量关于文件的信息。通常，只有该结构的两个字段对编写驱动代码有意义：

- **dev_t i_rdev**：对于表示设备文件的 inode，此字段包含实际的设备号。
- **struct cdev *i_cdev**：struct cdev 是内核内部表示字符设备的结构；当 inode 引用字符设备文件时，此字段包含指向该结构的指针。

在 2.5 开发系列的过程中，i_rdev 的类型发生了变化，导致许多驱动出现问题。为了鼓励更可移植的编程，内核开发者添加了两个宏，用于从 inode 中获取主设备号和次设备号：

```c
unsigned int iminor(struct inode *inode);
unsigned int imajor(struct inode *inode);
```

为了避免被未来的变化所困扰，应使用这些宏，而不是直接操作 i_rdev。

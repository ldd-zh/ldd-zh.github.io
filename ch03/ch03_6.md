# scull 的内存使用

在介绍 read 和 write 操作之前，我们最好先看看 scull 如何以及为什么执行内存分配。“如何”需要彻底理解代码，“为什么”展示了驱动编写者需要做出的选择，尽管 scull 绝对不是一个典型的设备。

本节仅涉及 scull 中的内存分配策略，并不展示编写真实驱动所需的硬件管理技能。这些技能在第9章和第10章中介绍。因此，如果你对理解面向内存的 scull 驱动的内部工作原理不感兴趣，可以跳过本节。

scull 使用的内存区域（也称为设备）的长度是可变的。你写入的数据越多，它增长得越多；通过用较短的文件覆盖设备来执行修剪。

scull 驱动引入了两个用于管理 Linux 内核内存的核心函数。这些函数定义在 <linux/slab.h> 中：

```c
void *kmalloc(size_t size, int flags);
void kfree(void *ptr);
```

调用 kmalloc 尝试分配 size 字节的内存；返回值是指向该内存的指针，如果分配失败则为 NULL。flags 参数用于描述应如何分配内存；我们将在第8章中详细检查这些标志。目前，我们始终使用 GFP_KERNEL。分配的内存应使用 kfree 释放。你不应将任何未从 kmalloc 获得的内容传递给 kfree。然而，将 NULL 指针传递给 kfree 是合法的。

kmalloc 不是分配大块内存的最有效方式（参见第8章），因此为 scull 选择的实现并不是特别聪明。智能实现的源代码将更难阅读，而本节的目标是展示 read 和 write，而不是内存管理。这就是为什么代码只使用 kmalloc 和 kfree，而不使用整个页面的分配，尽管这种方法会更有效。

另一方面，我们不想限制“设备”区域的大小，这既是出于哲学原因，也是出于实际原因。从哲学上讲，对正在管理的数据项设置任意限制总是一个坏主意。实际上，scull 可以用于临时占用系统的内存以在低内存条件下运行测试。运行此类测试可能有助于你理解系统的内部结构。你可以使用命令 cp /dev/zero /dev/scull0 来使用 scull 占用所有实际 RAM，并且你可以使用 dd 实用程序选择将多少数据复制到 scull 设备。

在 scull 中，每个设备是一个指针链表，每个指针指向一个 scull_dev 结构。每个这样的结构默认最多可以引用四百万字节，通过一个中间指针数组。发布的源代码使用一个包含 1000 个指针的数组，每个指针指向 4000 字节的区域。我们将每个内存区域称为一个量子，将数组（或其长度）称为量子集。scull 设备及其内存区域如图 3-1 所示。

图 3-1. scull 设备的布局

选择的数字使得在 scull 中写入单个字节会消耗 8000 或 12000 字节的内存：4000 用于量子，4000 或 8000 用于量子集（根据目标平台上指针是 32 位还是 64 位）。相反，如果你写入大量数据，链表的开销并不太糟糕。每四兆字节数据只有一个链表元素，设备的最大大小受计算机内存大小的限制。

选择适当的量子大小和量子集大小是一个策略问题，而不是机制问题，最佳大小取决于设备的使用方式。因此，scull 驱动不应强制使用任何特定的量子大小和量子集大小。在 scull 中，用户可以通过多种方式更改负责的值：通过在编译时更改 scull.h 中的宏 SCULL_QUANTUM 和 SCULL_QSET，通过在模块加载时设置整数值 scull_quantum 和 scull_qset，或通过在运行时使用 ioctl 更改当前值和默认值。

使用宏和整数值来允许编译时和加载时配置让人想起如何选择主设备号。我们使用此技术来处理驱动中与策略相关的任意值。

剩下的唯一问题是如何选择默认数字。在这种情况下，问题在于找到由于半满量子和量子集导致的内存浪费与如果量子和集很小而发生的分配、释放和指针链接开销之间的最佳平衡。此外，还应考虑 kmalloc 的内部设计。（我们现在不会深入探讨这一点；kmalloc 的内部结构在第8章中探讨。）默认数字的选择基于假设在测试 scull 时可能会向其写入大量数据，尽管设备的正常使用很可能只传输几千字节的数据。

我们已经看到了表示我们设备内部的 scull_dev 结构。该结构的 quantum 和 qset 字段分别保存设备的量子大小和量子集大小。然而，实际数据由不同的结构跟踪，我们称之为 struct scull_qset：

```c
struct scull_qset {
    void **data;
    struct scull_qset *next;
};
```

下一个代码片段展示了如何在实践中使用 struct scull_dev 和 struct scull_qset 来保存数据。函数 scull_trim 负责释放整个数据区域，并在文件以写方式打开时由 scull_open 调用。它只是遍历列表并释放它找到的任何量子和量子集。

```c
int scull_trim(struct scull_dev *dev)
{
    struct scull_qset *next, *dptr;
    int qset = dev->qset; /* "dev" 不为空 */
    int i;

    for (dptr = dev->data; dptr; dptr = next) { /* 所有列表项 */
        if (dptr->data) {
            for (i = 0; i < qset; i++)
                kfree(dptr->data[i]);
            kfree(dptr->data);
            dptr->data = NULL;
        }
        next = dptr->next;
        kfree(dptr);
    }
    dev->size = 0;
    dev->quantum = scull_quantum;
    dev->qset = scull_qset;
    dev->data = NULL;
    return 0;
}
```

scull_trim 还用于在模块清理函数中将 scull 使用的内存返回给系统。

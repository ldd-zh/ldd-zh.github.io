# open 和 release

现在我们已经快速浏览了这些字段，我们开始在真实的 scull 函数中使用它们。

## open 方法

open 方法是为驱动准备的，以便为后续操作进行任何初始化。在大多数驱动中，open 应执行以下任务：

- 检查设备特定的错误（如设备未准备好或类似的硬件问题）
- 如果设备是第一次打开，则初始化设备
- 如果需要，更新 f_op 指针
- 分配并填充要放入 flip->private_data 的任何数据结构

然而，首要任务通常是识别正在打开的设备。请记住，open 方法的原型是：

```c
int (*open)(struct inode *inode, struct file *filp);
```

inode 参数包含我们需要的信息，形式为 i_cdev 字段，其中包含我们之前设置的 cdev 结构。唯一的问题是我们通常不想要 cdev 结构本身，而是包含该 cdev 结构的 scull_dev 结构。C 语言允许程序员进行各种技巧来实现这种转换；然而，编写这种技巧容易出错，并且会导致代码难以阅读和理解。幸运的是，在这种情况下，内核黑客已经为我们完成了这些技巧，形式为 container_of 宏，定义在 <linux/kernel.h> 中：

```c
container_of(pointer, container_type, container_field);
```

此宏接受一个指向 container_type 结构内的 container_field 字段的指针，并返回指向包含结构的指针。在 scull_open 中，此宏用于查找适当的设备结构：

```c
struct scull_dev *dev; /* 设备信息 */

dev = container_of(inode->i_cdev, struct scull_dev, cdev);
filp->private_data = dev; /* 供其他方法使用 */
```

一旦找到 scull_dev 结构，scull 将其指针存储在 file 结构的 private_data 字段中，以便将来更容易访问。

识别正在打开的设备的另一种方法是查看存储在 inode 结构中的次设备号。如果你使用 register_chrdev 注册设备，则必须使用此技术。确保使用 iminor 从 inode 结构中获取次设备号，并确保它对应于你的驱动实际准备处理的设备。

scull_open 的（稍微简化的）代码如下：

```c
int scull_open(struct inode *inode, struct file *filp)
{
    struct scull_dev *dev; /* 设备信息 */
    dev = container_of(inode->i_cdev, struct scull_dev, cdev);
    filp->private_data = dev; /* 供其他方法使用 */
    /* 如果以只写方式打开，则将设备长度修剪为 0 */
    if ((filp->f_flags & O_ACCMODE) == O_WRONLY) {
        scull_trim(dev); /* 忽略错误 */
    }
    return 0; /* 成功 */
}
```

代码看起来相当简单，因为在调用 open 时它没有执行任何特定的设备处理。它不需要这样做，因为 scull 设备在设计上是全局且持久的。具体来说，没有诸如“在第一次打开时初始化设备”之类的操作，因为我们不为 scull 保留打开计数。

对设备执行的唯一真正操作是在以写方式打开设备时将其长度修剪为 0。执行此操作是因为，根据设计，用较短的文件覆盖 scull 设备会导致设备数据区域变短。这类似于以写方式打开常规文件会将其长度修剪为 0。如果设备以读方式打开，则此操作不执行任何操作。

我们稍后将在查看其他 scull 变体的代码时看到真正的初始化是如何工作的。

## release 方法

release 方法的作用与 open 相反。有时你会发现方法实现称为 device_close 而不是 device_release。无论哪种方式，设备方法应执行以下任务：

- 释放 open 在 flip->private_data 中分配的任何内容
- 在最后一次关闭时关闭设备

基本形式的 scull 没有硬件需要关闭，因此所需的代码非常少：

```c
int scull_release(struct inode *inode, struct file *filp)
{
    return 0;
}
```

* 其他设备变体由不同的函数关闭，因为 scull_open 为每个设备替换了不同的 flip->f_op。我们将在介绍每个变体时讨论这些。

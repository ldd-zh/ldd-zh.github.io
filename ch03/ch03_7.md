# read 和 write

read 和 write 方法都执行类似的任务，即从应用程序代码复制数据或向应用程序代码复制数据。因此，它们的原型非常相似，值得同时介绍它们：

```c
ssize_t read(struct file *filp, char __user *buff, size_t count, loff_t *offp);
ssize_t write(struct file *filp, const char __user *buff, size_t count, loff_t *offp);
```

对于这两种方法，filp 是文件指针，count 是请求的数据传输大小。buff 参数指向用户缓冲区，该缓冲区保存要写入的数据或应放置新读取数据的空缓冲区。最后，offp 是指向“长偏移类型”对象的指针，该对象指示用户正在访问的文件位置。返回值是“有符号大小类型”；其用法稍后讨论。

让我们重复一遍，read 和 write 方法的 buff 参数是用户空间指针。因此，内核代码不能直接解引用它。此限制有几个原因：

- 根据你的驱动运行的架构以及内核的配置方式，用户空间指针在内核模式下可能完全无效。该地址可能没有映射，或者它可能指向一些其他随机数据。
- 即使指针在内核空间中有相同的含义，用户空间内存是分页的，并且系统调用时相关内存可能不在 RAM 中。尝试直接引用用户空间内存可能会生成页面错误，这是内核代码不允许的。结果将是一个“oops”，这将导致发出系统调用的进程死亡。
- 该指针由用户程序提供，该程序可能有错误或恶意。如果你的驱动盲目地解引用用户提供的指针，它将为用户空间程序打开一个访问或覆盖系统中任何内存的大门。如果你不希望对你用户系统的安全负责，你绝不能直接解引用用户空间指针。

显然，你的驱动必须能够访问用户空间缓冲区才能完成其工作。然而这种访问必须始终通过内核提供的特殊函数来执行，以确保安全。我们在这里介绍一些这些函数（定义在 <asm/uaccess.h> 中），其余的将在第1章的“使用 ioctl 参数”部分中介绍；它们使用一些特殊的、依赖于架构的技巧来确保内核和用户空间之间的数据传输是安全和正确的。

scull 中的 read 和 write 代码需要将整个数据段复制到用户地址空间或从用户地址空间复制。以下内核函数提供了这种能力，它们复制任意字节数组，并且是大多数 read 和 write 实现的核心：

```c
unsigned long copy_to_user(void __user *to, const void *from, unsigned long count);
unsigned long copy_from_user(void *to, const void __user *from, unsigned long count);
```

尽管这些函数的行为类似于普通的内存函数，但在从内核代码访问用户空间时必须格外小心。所寻址的用户页面可能当前不在内存中，虚拟内存子系统可能会在页面被传输到适当位置时将进程置于睡眠状态。例如，当页面必须从交换空间检索时，就会发生这种情况。对于驱动编写者来说，最终结果是任何访问用户空间的函数都必须是可重入的，必须能够与其他驱动函数并发执行，并且特别是必须处于可以合法睡眠的位置。我们将在第5章中回到这个主题。

这两个函数的作用不仅限于将数据复制到用户空间和从用户空间复制数据：它们还检查用户空间指针是否有效。如果指针无效，则不执行复制；如果在复制过程中遇到无效地址，则只复制部分数据。在这两种情况下，返回值是仍需复制的内存量。scull 代码会检查此错误返回，如果不是 0，则向用户返回 -EFAULT。

用户空间访问和无效用户空间指针的主题有些高级，将在第6章中讨论。然而，值得注意的是，如果你不需要检查用户空间指针，你可以调用 __copy_to_user 和 __copy_from_user。例如，如果你知道你已经检查了参数，这很有用。但要小心；如果你确实没有检查你传递给这些函数的用户空间指针，那么你可能会创建内核崩溃和/或安全漏洞。

就实际的设备方法而言，read 方法的任务是将数据从设备复制到用户空间（使用 copy_to_user），而 write 方法必须将数据从用户空间复制到设备（使用 copy_from_user）。每个 read 或 write 系统调用请求传输特定数量的字节，但驱动可以自由传输较少的数据——确切的规则对于读取和写入略有不同，并在本章后面描述。

无论方法传输的数据量如何，它们通常应在成功完成系统调用后更新 *offp 处的文件位置以表示当前文件位置。然后，内核在适当时将文件位置更改传播回文件结构。然而，pread 和 pwrite 系统调用具有不同的语义；它们从给定的文件偏移量操作，并且不会更改其他系统调用看到的文件位置。这些调用传递一个指向用户提供的位置的指针，并丢弃你的驱动所做的更改。

图 3-2 表示典型的 read 实现如何使用其参数。

```c
ssize_t dev_read(struct file *file, char *buf, size_t count, loff_t *ppos);
```

图 3-2. read 的参数

如果发生错误，read 和 write 方法都返回负值。返回值大于或等于 0 时，告诉调用程序成功传输了多少字节。如果某些数据正确传输，然后发生错误，则返回值必须是成功传输的字节数，并且错误直到下次调用函数时才会报告。实现此约定当然要求你的驱动记住错误已发生，以便将来返回错误状态。

尽管内核函数返回负数以表示错误，并且该数字的值指示发生的错误类型（如第2章中介绍），但在用户空间中运行的程序总是将 -1 视为错误返回值。它们需要访问 errno 变量以找出发生了什么。用户空间行为由 POSIX 标准规定，但该标准不对内核的内部操作提出要求。

## read 方法

read 的返回值由调用应用程序解释：

- 如果该值等于传递给 _read 系统调用的 count 参数，则已传输请求的字节数。这是最佳情况。
- 如果该值为正但小于 count，则仅传输了部分数据。这可能是由于设备的原因，具体取决于设备。大多数情况下，应用程序会重试读取。例如，如果你使用 fread 函数读取，库函数会重新发出系统调用，直到完成请求的数据传输。
- 如果该值为 0，则已达到文件末尾（并且未读取任何数据）。
- 负值表示发生了错误。该值指定了错误类型，根据 <linux/errno.h>。典型的错误返回值包括 -EINTR（中断的系统调用）或 -EFAULT（错误的地址）。

前面的列表中缺少的是“没有数据，但可能稍后到达”的情况。在这种情况下，read 系统调用应阻塞。我们将在第6章中处理阻塞输入。

scull 代码利用了这些规则。特别是，它利用了部分读取规则。每次调用 scull_read 只处理一个数据量子，而不实现循环来收集所有数据；这使得代码更短且更易于阅读。如果读取程序确实需要更多数据，它会重新调用。如果使用标准 I/O 库（即 fread）读取设备，应用程序甚至不会注意到数据传输的量子化。

如果当前读取位置大于设备大小，scull 的 _read 方法返回 0 以表示没有可用数据（换句话说，我们处于文件末尾）。如果进程 A 正在读取设备而进程 B 以写方式打开它，从而将设备长度截断为 0，则可能会发生这种情况。进程 A 突然发现自己超过了文件末尾，下一次读取调用返回 0。

以下是 read 的代码（暂时忽略对 down_interruptible 和 up 的调用；我们将在下一章中讨论它们）：

```c
ssize_t scull_read(struct file *filp, char __user *buf, size_t count, loff_t *f_pos)
{
    struct scull_dev *dev = filp->private_data;
    struct scull_qset *dptr; /* 第一个列表项 */
    int quantum = dev->quantum, qset = dev->qset;
    int itemsize = quantum * qset; /* 列表项中有多少字节 */
    int item, s_pos, q_pos, rest;
    ssize_t retval = 0;

    if (down_interruptible(&dev->sem))
        return -ERESTARTSYS;
    if (*f_pos >= dev->size)
        goto out;
    if (*f_pos + count > dev->size)
        count = dev->size - *f_pos;

    /* 找到列表项、量子集索引和量子中的偏移量 */
    item = (long)*f_pos / itemsize;
    rest = (long)*f_pos % itemsize;
    s_pos = rest / quantum; q_pos = rest % quantum;

    /* 跟随列表到正确的位置（在其他地方定义） */
    dptr = scull_follow(dev, item);

    if (dptr == NULL || !dptr->data || !dptr->data[s_pos])
        goto out; /* 不要填充空洞 */

    /* 只读取到此量子的末尾 */
    if (count > quantum - q_pos)
        count = quantum - q_pos;

    if (copy_to_user(buf, dptr->data[s_pos] + q_pos, count)) {
        retval = -EFAULT;
        goto out;
    }
    *f_pos += count;
    retval = count;

out:
    up(&dev->sem);
    return retval;
}
```

## write 方法

write 与 read 类似，可以传输比请求少的数据，根据以下返回值规则：

- 如果该值等于 count，则已传输请求的字节数。
- 如果该值为正但小于 count，则仅传输了部分数据。程序很可能会重试写入剩余的数据。
- 如果该值为 0，则未写入任何内容。此结果不是错误，并且没有理由返回错误代码。再次，标准库会重试 write 调用。我们将在第6章中介绍阻塞 write 时检查此情况的确切含义。
- 负值表示发生了错误；与 read 一样，有效的错误值是 <linux/errno.h> 中定义的那些。

不幸的是，仍然有一些行为不当的程序在部分传输时发出错误消息并中止。这是因为一些程序员习惯于看到完全失败或完全成功的 write 调用，这实际上是大多数情况下发生的情况，并且应该由设备支持。scull 实现中的此限制可以修复，但我们不想使代码比必要的更复杂。

scull 的 write 代码与 read 方法一样，一次处理一个量子：

```c
ssize_t scull_write(struct file *filp, const char __user *buf, size_t count, loff_t *f_pos)
{
    struct scull_dev *dev = filp->private_data;
    struct scull_qset *dptr;
    int quantum = dev->quantum, qset = dev->qset;
    int itemsize = quantum * qset;
    int item, s_pos, q_pos, rest;
    ssize_t retval = -ENOMEM; /* 用于 "goto out" 语句的值 */

    if (down_interruptible(&dev->sem))
        return -ERESTARTSYS;

    /* 找到列表项、量子集索引和量子中的偏移量 */
    item = (long)*f_pos / itemsize;
    rest = (long)*f_pos % itemsize;
    s_pos = rest / quantum; q_pos = rest % quantum;

    /* 跟随列表到正确的位置 */
    dptr = scull_follow(dev, item);
    if (dptr == NULL)
        goto out;
    if (!dptr->data) {
        dptr->data = kmalloc(qset * sizeof(char *), GFP_KERNEL);
        if (!dptr->data)
            goto out;
        memset(dptr->data, 0, qset * sizeof(char *));
    }
    if (!dptr->data[s_pos]) {
        dptr->data[s_pos] = kmalloc(quantum, GFP_KERNEL);
        if (!dptr->data[s_pos])
            goto out;
    }
    /* 只写入到此量子的末尾 */
    if (count > quantum - q_pos)
        count = quantum - q_pos;

    if (copy_from_user(dptr->data[s_pos] + q_pos, buf, count)) {
        retval = -EFAULT;
        goto out;
    }
    *f_pos += count;
    retval = count;

    /* 更新大小 */
    if (dev->size < *f_pos)
        dev->size = *f_pos;

out:
    up(&dev->sem);
    return retval;
}
```

## readv 和 writev

Unix 系统长期以来支持两个名为 readv 和 writev 的系统调用。这些“向量”版本的 read 和 write 采用一个结构数组，每个结构包含一个指向缓冲区的指针和一个长度值。readv 调用将依次读取每个缓冲区中指示的数量。writev 将收集每个缓冲区的内容并将它们作为单个写入操作输出。

如果你的驱动不提供处理向量操作的方法，readv 和 writev 将通过多次调用你的 read 和 write 方法来实现。然而，在许多情况下，通过直接实现 readv 和 writev 可以实现更高的效率。

向量操作的原型是：

```c
ssize_t (*readv) (struct file *filp, const struct iovec *iov, unsigned long count, loff_t *ppos);
ssize_t (*writev) (struct file *filp, const struct iovec *iov, unsigned long count, loff_t *ppos);
```

在这里，filp 和 ppos 参数与 read 和 write 相同。iovec 结构定义在 <linux/uio.h> 中，如下所示：

```c
struct iovec {
    void __user *iov_base;
    __kernel_size_t iov_len;
};
```

每个 iovec 描述要传输的一块数据；它从 iov_base（在用户空间中）开始，长度为 iov_len 字节。count 参数告诉方法有多少个 iovec 结构。这些结构由应用程序创建，但内核在调用驱动之前将它们复制到内核空间。

向量操作的最简单实现是一个简单的循环，将每个 iovec 的地址和长度传递给驱动的 read 或 write 函数。然而，通常高效且正确的行为要求驱动做更聪明的事情。例如，磁带驱动器上的 writev 应将所有 iovec 结构的内容作为磁带上的单个记录写入。

然而，许多驱动从实现这些方法本身中得不到任何好处。因此，scull 省略了它们。内核使用 read 和 write 模拟它们，最终结果是相同的。

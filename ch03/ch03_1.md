# scull 的设计

编写驱动的第一步是定义驱动将向用户程序提供的功能（机制）。由于我们的“设备”是计算机内存的一部分，我们可以自由地对其进行操作。它可以是一个顺序访问设备或随机访问设备，可以是一个设备或多个设备，等等。

为了使 scull 成为编写真实设备驱动的模板，我们将展示如何在计算机内存上实现几种设备抽象，每种抽象都有不同的特性。

scull 源代码实现了以下设备。模块实现的每种设备类型被称为一种类型。

- **scull0 到 scull3**：四个设备，每个设备由一个全局且持久的内存区域组成。全局意味着如果设备被多次打开，设备中包含的数据将被所有打开它的文件描述符共享。持久意味着如果设备被关闭并重新打开，数据不会丢失。这个设备可以很有趣地使用，因为它可以使用常规命令（如 cp、cat 和 shell I/O 重定向）进行访问和测试。

- **scullpipe0 到 scullpipe3**：四个 FIFO（先进先出）设备，它们的行为类似于管道。一个进程读取另一个进程写入的内容。如果多个进程读取同一设备，它们将竞争数据。scullpipe 的内部实现展示了如何在不使用中断的情况下实现阻塞和非阻塞的读写操作。尽管真实驱动通常使用硬件中断与设备同步，但阻塞和非阻塞操作是一个重要的话题，与中断处理（第10章讨论）是分开的。

- **scullsingle、scullpriv、sculluid、scullwuid**：这些设备与 scull0 类似，但在打开时有一些限制。第一个（scullsingle）只允许一个进程使用驱动，而 scullpriv 对每个虚拟控制台（或 X 终端会话）是私有的，因为每个控制台/终端上的进程获得不同的内存区域。sculluid 和 scullwuid 可以被多次打开，但每次只能由一个用户打开；前者在另一个用户锁定设备时返回“设备忙”错误，而后者实现阻塞打开。这些 scull 的变体似乎混淆了策略和机制，但它们值得一看，因为一些现实生活中的设备需要这种管理。

每个 scull 设备展示了驱动的不同特性，并提出了不同的挑战。本章涵盖了 scull0 到 scull3 的内部实现；更高级的设备将在第6章中讨论。scullpipe 在“阻塞 I/O 示例”部分中描述，其他设备在“设备文件的访问控制”部分中描述。

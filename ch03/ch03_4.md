# 字符设备注册

如前所述，内核使用 struct cdev 类型的结构在内部表示字符设备。在内核调用你的设备操作之前，你必须分配并注册一个或多个这些结构。为此，你的代码应包含 <linux/cdev.h>，其中定义了该结构及其相关的辅助函数。

有两种方法可以分配和初始化这些结构。如果你希望在运行时获取一个独立的 cdev 结构，可以使用如下代码：

```c
struct cdev *my_cdev = cdev_alloc();
my_cdev->ops = &my_fops;
```

然而，你可能希望将 cdev 结构嵌入到你自己的设备特定结构中；scull 就是这样做的。在这种情况下，你应该使用以下代码初始化你已经分配的结构：

```c
void cdev_init(struct cdev *cdev, struct file_operations *fops);
```

无论哪种方式，你都需要初始化 struct cdev 的另一个字段。与 file_operations 结构一样，struct cdev 有一个 owner 字段，应设置为 THIS_MODULE。

一旦 cdev 结构设置完毕，最后一步是通过调用以下函数告诉内核：

```c
int cdev_add(struct cdev *dev, dev_t num, unsigned int count);
```

在这里，dev 是 cdev 结构，num 是此设备响应的第一个设备号，count 是应与设备关联的设备号数量。通常 count 为 1，但在某些情况下，让多个设备号对应特定设备是有意义的。例如，SCSI 磁带驱动允许用户空间通过为每个物理设备分配多个次设备号来选择操作模式（如密度）。

使用 cdev_add 时需要注意几点。首先，此调用可能会失败。如果它返回一个负的错误代码，你的设备将不会被添加到系统中。然而，它几乎总是成功的，这引出了另一点：一旦 cdev_add 返回，你的设备就“激活”了，内核可以调用其操作。你不应在驱动完全准备好处理设备操作之前调用 cdev_add。

要从系统中删除字符设备，请调用：

```c
void cdev_del(struct cdev *dev);
```

显然，在将 cdev 结构传递给 cdev_del 后，你不应再访问它。

## scull 中的设备注册

在内部，scull 使用 struct scull_dev 类型的结构表示每个设备。该结构定义如下：

```c
struct scull_dev {
    struct scull_qset *data; /* 指向第一个量子集的指针 */
    int quantum; /* 当前量子大小 */
    int qset; /* 当前数组大小 */
    unsigned long size; /* 存储在此处的数据量 */
    unsigned int access_key; /* 由 sculluid 和 scullpriv 使用 */
    struct semaphore sem; /* 互斥信号量 */
    struct cdev cdev; /* 字符设备结构 */
};
```

我们将在讨论各个字段时介绍它们，但现在我们注意到 cdev，即 struct cdev，它将我们的设备与内核接口连接起来。必须按照上述方式初始化和添加此结构；处理此任务的 scull 代码如下：

```c
static void scull_setup_cdev(struct scull_dev *dev, int index)
{
    int err, devno = MKDEV(scull_major, scull_minor + index);

    cdev_init(&dev->cdev, &scull_fops);
    dev->cdev.owner = THIS_MODULE;
    dev->cdev.ops = &scull_fops;
    err = cdev_add(&dev->cdev, devno, 1);
    /* 如果需要，优雅地处理失败 */
    if (err)
        printk(KERN_NOTICE "Error %d adding scull%d", err, index);
}
```

由于 cdev 结构嵌入在 struct scull_dev 中，必须调用 cdev_init 来初始化该结构。

## 旧的方式

如果你深入研究 2.6 内核中的许多驱动代码，你可能会注意到许多字符驱动没有使用我们刚刚描述的 cdev 接口。你看到的是尚未升级到 2.6 接口的旧代码。由于该代码仍然有效，这种升级可能不会很快发生。为了完整起见，我们描述了旧的字符设备注册接口，但新代码不应使用它；这种机制可能会在未来的内核中消失。

注册字符设备驱动的经典方式是：

```c
int register_chrdev(unsigned int major, const char *name,
                    struct file_operations *fops);
```

在这里，major 是感兴趣的主设备号，name 是驱动的名称（它出现在 /proc/devices 中），fops 是默认的 file_operations 结构。调用 register_chrdev 会为给定的主设备号注册次设备号 0-255，并为每个设备设置一个默认的 cdev 结构。使用此接口的驱动必须准备好处理所有 256 个次设备号上的 open 调用（无论它们是否对应真实设备），并且它们不能使用大于 255 的主设备号或次设备号。

如果你使用 register_chrdev，从系统中删除设备的正确函数是：

```c
int unregister_chrdev(unsigned int major, const char *name);
```

major 和 name 必须与传递给 register_chrdev 的值相同，否则调用将失败。
